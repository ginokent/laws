#!/bin/sh
# shellcheck disable=SC1117

# TODO: make more readable.

# If in non interactive shell ( "$-" not containing "i" ), execute "laws" as command.
if ! { echo "$-" | grep -q 'i'; }; then

  # If an error occurs, terminate abnormally.
  set -e

  # Global variables
  readonly VERSION='0.1.4'
  readonly PROGRAM_NAME="$(basename -- "$0")"

  # When exiting, clean up temporary files.
  trap '
    if [ -f "${tmpFile}" ]; then
      rm -f ${tmpFile}
    fi
    if [ -f "${tmpFileForS3ToS3}" ]; then
      rm -f ${tmpFileForS3ToS3}
    fi' EXIT

  ##
  # Output README
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   string README
  # Return:
  #   0 always
  ##
  PrintErrReadMe() { (
  cat <<'README' >/dev/stderr

laws
====

Lightweight shell script for Amazon Web Service Command Line Interface like AWS CLI.


## TL;DR

    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls s3://your-bucket/prefix
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cat s3://your-bucket/path/to/file
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cp s3://your-bucket/path/to/file /path/to/file


## Install:

    sudo curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws -o /usr/local/bin/laws && sudo chmod +x $_


## Usage:

When executing this script,
  - Please use it on EC2 which has IAM Role allowed access to Amazon S3,
  - or save `~/.aws/config` and `~/.aws/credentials`,
  - or set the following environment variables:

    ```
    $ export AWS_REGION=ap-northeast-1
    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
    ```


#### `help`
Display help.  

    $ laws help


#### `s3 ls`
List the contents on Amazon S3.  

    $ laws s3 ls [<your-bucket>[<prefix>]]


#### `s3 cat`
Get the contents of the file on Amazon S3.  

    $ laws s3 cat s3://your-bucket/path/to/file ...


#### `s3 cp`
Copy a file.  

    $ laws s3 cp s3://your-bucket/path/to/file /path/to/file
    $ laws s3 cp /path/to/file s3://your-bucket/path/to/file
    $ laws s3 cp s3://your-bucket-b/path/to/file s3://your-bucket-a/path/to/file


#### completion
Tab Completion.

    $ . $(command -v laws)

OR  

    $ . /path/to/laws


## Note:
This program relies heavily on "AWS Signature Version 4".  

#### References:
  - Signing AWS Requests with Signature Version 4 - Amazon Web Services  
    https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html  
  - Authenticating Requests: Using Query Parameters (AWS Signature Version 4)
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  - Signature Calculations for the Authorization Header:  
    Transferring Payload in a Single Chunk (AWS Signature Version 4) - Amazon Simple Storage Service  
    https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html  
  - GET Bucket (List Objects) Version 2  
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html  

---
README
  )}

  ##
  # Output UTC date for log
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   string UTC date ISO 8601 format
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintDateUTC() { (
    LANG=C TZ=UTC date +'%Y%m%dT%H%M%SZ'
  )}

  ##
  # Output log
  # Arguments:
  #   $1 log level
  #   $2 log message
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   string log message
  # Return:
  #   0 always
  ##
  PrintErrLog() { (
    # vars
    level="${1:?"$(PrintDateUTC) [FATAL] PrintErrLog(): requires \"level\" as \$1"}"
    logMessages="${2:?"$(PrintDateUTC) [FATAL] PrintErrLog(): requires \"logMessages\" as \$2"}"
    
    # check level
    case "${level}" in
      f|F) tag='[FATAL]' ;;
      e|E) tag='[ERROR]' ;;
      w|W) tag='[WARN] ' ;;
        *) tag='[INFO] ' ;;
    esac

    # output log message to stderr
    printf '%s\n' "${logMessages}" | sed "s/^/$(PrintDateUTC) ${PROGRAM_NAME}[$$]: ${tag} /" >/dev/stderr
  )}

  ##
  # Check containing multi bytes character
  # Arguments:
  #   $1 content to be checked
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 containing
  #   1 NOT containing
  ##
  ContainMultiBytesChar() { (
    # Local vars
    data="$1"

    # Check containing
    echo "${data}" | LANG=C grep -Evq '^[[:cntrl:][:print:]]*$'
  )}

  ##
  # Check containing regex passed
  # Arguments:
  #   $1 regex pattern
  #   $2 content to be checked by pattern
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 containing
  #   1 NOT containing
  ##
  ContainRegex() { (
    # Local vars
    pattern="${1:?"$(PrintErrLog F "ContainRegex(): requires \"pattern\" as \$1")"}"
    data="$2"

    # Check containing
    echo "${data}" | grep -Eq -- "${pattern}"
  )}

  ##
  # Check containing "-h" or "--help" or "help"
  # Arguments:
  #   $1 regex pattern
  #   $2 content to be checked containing help option
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 containing
  #   1 NOT containing
  ##
  ContainHelpOption() { (
    #                  "-h" "--help"           "a -h b" "a --help b"  "help"
    ContainRegex '^[[:blank:]]*\-+h(elp)?|[[:blank:]]+\-+h(elp)?|^[[:blank:]]*help[[:blank:]]*$' "$*"
  )}

  ##
  # Check existing dependency commands in PATH
  # Arguments:
  #   $@ commands
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 exist
  #   1 NOT exist, EXIT immediately
  ##
  CheckDependency() { (
    for cmd in "$@"; do
      if ! { command -v -- "${cmd}" >/dev/null; }; then
        PrintErrLog E "CheckDependency(): \"${cmd}\" not found in PATH=\"${PATH}\""
        # If command not found in PATH, it terminates abnormally immediately.
        exit 1
      fi
    done
  )}

  ##
  # Parse INI file and Print stdout
  # Arguments:
  #   $1 ini file pattern like "[foobar]"
  #   $2 ini file path
  # Stdin:
  #   no
  # Stdout:
  #   string rarsed ini content as shell vars
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ParseINIforEval() { (
    # For the setting in the ini file, output commands which define them as shell variables prefixed "INI_".
    iniSectionPattern="${1:?"$(PrintErrLog F "ParseINIforEval(): requires \"iniSectionPattern\" as \$1")"}"
    file="${2:?"$(PrintErrLog F "ParseINIforEval(): requires \"file\" as \$2")"}"
    sed "
      s/[[:blank:]]*\=[[:blank:]]*/=/g
      s/[#;].*$//
      s/[[:blank:]]*$//
      s/^[[:blank:]]*//
      s/^\(.*\)=\([^\"\']*\)$/INI_\1=\"\2\"/
      " "${file}" \
      | sed -n "/^\[${iniSectionPattern}\]/,/\[/{/.*\=.*/p;}"
  )}

  ##
  # Convert hexadecimal
  # Arguments:
  #   $1 content converted to hexadecimal
  # Stdin:
  #   no
  # Stdout:
  #   string converted hexadecimal data
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ConvertHex() { (
    printf '%s' "$1" | od -v -A n -t x1 | tr -Cd '0123456789abcdefABCDEF'
  )}

  ##
  # Convert $2 (sha256 HMAC) by $1
  # Arguments:
  #   $1 HEXADECIMAL key
  #   $2 data be converted
  # Stdin:
  #   no
  # Stdout:
  #   string converted data
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ConvertHMAC() { (
    printf '%s' "$2" | openssl dgst -sha256 -mac HMAC -macopt hexkey:"$1" | sed 's/^.*[[:blank:]]//'
  )}

  ##
  # Convert $1 by sha256
  # Arguments:
  #   $1 data
  # Stdin:
  #   no
  # Stdout:
  #   string converted data
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ConvertSHA256Hash() { (
    printf '%s' "$1" | openssl dgst -sha256 | sed 's/^.*[[:blank:]]//'
  )}

  ##
  # Print string scheme+slash+slash ( like http:// https:// s3:// ssh:// ... ) removed
  # Arguments:
  #   $1 data
  # Stdin:
  #   no
  # Stdout:
  #   string removed "s3://"
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintSchemeSlashSlashRemoved() { (
    printf '%s' "$1" | sed 's|^[^:]*://||'
  )}

  ##
  # Print string extracted by pattern
  # Arguments:
  #   $1 data
  # Stdin:
  #   no
  # Stdout:
  #   string extracted by pattern
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedByPattern() { (
    pattern="${1:?"$(PrintErrLog F "PrintExtractedByPattern(): requires \"pattern\" as \$1")"}"
    data="${2:?"$(PrintErrLog F "PrintExtractedByPattern(): requires \"data\" as \$2")"}"
    echo "${data}" | grep -Eo -- "${pattern}"
  )}

  ##
  # Print string extracted XML value
  # Arguments:
  #   $1 XML tag
  #   $2 extracted data
  # Stdin:
  #   no
  # Stdout:
  #   string extracted by XML tag
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedXMLValue() { (
    tagName="${1:?"$(PrintErrLog F "PrintExtractedXMLValue(): requires \"tagName\" as \$1")"}"
    data="${2:?"$(PrintErrLog F "PrintExtractedXMLValue(): requires \"data\" as \$2")"}"
    echo "${data}" | grep -Eo "<${tagName}>.*</${tagName}>" | sed "s|</?${tagName}>||g"
  )}

  ##
  # Print string extracted HTTP host
  # Arguments:
  #   $1 uri
  # Stdin:
  #   no
  # Stdout:
  #   string extracted host
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedHTTPHost() { (
    PrintSchemeSlashSlashRemoved "$1" | sed 's|/.*||'
  )}

  ##
  # Print string extracted HTTP path
  # Arguments:
  #   $1 uri
  # Stdin:
  #   no
  # Stdout:
  #   string extracted path
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedHTTPPath() { (
    PrintSchemeSlashSlashRemoved "$1" | grep '/' | sed 's|^[^/]*/||'
  )}

  ##
  # Print string uri encoded
  # Arguments:
  #   $1 uri
  # Stdin:
  #   no
  # Stdout:
  #   string uri encoded
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  CommonStdoutUriEncoded() { (
    data="$1"
    if ContainMultiBytesChar "${data}"; then
      PrintErrLog E "containing multi bytes char"
      # If multi-byte characters are included, abnormal termination immediately.
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      # shellcheck disable=SC1001
      case "$LINE" in
        [[:alnum:]~_\.\-])
          printf '%s' "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  )}

  CommonStdoutUriEncodedWithoutSlash() {
    data="$1"
    if ContainMultiBytesChar "${data}"; then
      PrintErrLog E "containing multi bytes char"
      # If multi-byte characters are included, abnormal termination immediately.
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        /|[[:alnum:].~_-])
          printf '%s' "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  }

  LawsStdoutRegion() { (
    # 1. environment variable: AWS_REGION
    [ -z "${AWS_REGION}" ] || { echo "${AWS_REGION}"; return 0; }

    # 2. config file: ~/.aws/config
    if [ -r ~/.aws/config ]; then
      INI_region=""
      eval "$(ParseINIforEval "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/config)"
      if [ "${INI_region}" ]; then
        echo "${INI_region}"
      else
        PrintErrLog W "LawsStdoutRegion(): Failed to parse ~/.aws/config: AWS_PROFILE=${AWS_PROFILE:-default}"
      fi
    fi

    # 3. meta-data
    if ! curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.$//'; then
      PrintErrLog E "$(cat <<"ERROR"

LawsStdoutRegion(): Not specified AWS Region
Follow the steps below to register AWS region:

1. Save config as: ~/.aws/config

    [default]
    region = ap-northeast-1

 ** OR **

1. Set environment variables:

    $ export AWS_REGION=ap-northeast-1

---
ERROR
      )"
      # If a region is not specified, abnormally terminates immediately.
      exit 1
    fi
  )}

  LawsStdoutAPIEndpoint() { (
    [ -z "${APIEndpoint}" ] || { echo "${APIEndpoint}"; return 0; }
    service="${1:?"$(PrintErrLog F "LawsStdoutAPIEndpoint(): requires \"service\" as \$1")"}"
    region="${2:?"$(PrintErrLog F "LawsStdoutAPIEndpoint(): requires \"region\" as \$2")"}"
    case "${service}" in
      s3) [ "${region}" = us-east-1 ] && echo "s3.amazonaws.com" || echo "s3-${region}.amazonaws.com" ;;
       *) PrintErrLog E "${service} not support"; return 1 ;;
    esac
  )}

  LawsSetAccessKey() {
    # get credentials from environment variables
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ "${AWS_ACCESS_KEY_ID}" ] && [ "${AWS_SECRET_ACCESS_KEY}" ]; then
        AccessKeyId="${AWS_ACCESS_KEY_ID}" SecretAccessKey="${AWS_SECRET_ACCESS_KEY}"
      fi
    fi

    # get credentials from `~/.aws/config` and `~/.aws/credentials`
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ -r ~/.aws/credentials ]; then
        INI_aws_access_key_id="" INI_aws_secret_access_key=""
        eval "$(ParseINIforEval "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/credentials)"
        AccessKeyId="${INI_aws_access_key_id}" SecretAccessKey="${INI_aws_secret_access_key}"
        if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
          PrintErrLog W "LawsSetAccessKey(): Failed to parse ~/.aws/credentials: AWS_PROFILE=${AWS_PROFILE:-default}"
        fi
      fi
    fi

    # get credentials from Instance Profile
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      instanceProfile=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || :)
      secCredJSON=$(curl -sS --max-time 1 "http://169.254.169.254/latest/meta-data/iam/security-credentials/${instanceProfile}" 2>/dev/null ||:)
      AccessKeyId=$(echo "${secCredJSON}" | grep "AccessKeyId" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      SecretAccessKey=$(echo "${secCredJSON}" | grep "SecretAccessKey" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      STSToken=$(echo "${secCredJSON}" | grep "Token" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')

      # if STSToken is null, regarding as not running on EC2.
      if [ -z "${STSToken}" ]; then
        PrintErrLog E "$(cat <<"ERROR"

LawsSetAccessKey(): Failed to connect http://169.254.169.254/
Follow the steps below to register your credentials:

1. Save credentials file as: ~/.aws/credentials

    [default]
    aws_access_key_id = AKIA****************
    aws_secret_access_key = ****************************************

 ** OR **

1. Set environment variables:

    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************

---
ERROR
        )"
      # If the secret key can not be acquired, the abnormal end immediately.
      exit 1
      fi
    fi
  }

  LawsStdoutHeader() {
    printf "%s\n" "host:${APIEndpoint}"
    [ "${HTTPMethod}" != PUT ] || printf "%s\n" "content-type:text/plain" # PUT
    printf "%s\n" "x-amz-content-sha256:${HashedPayload}"
    printf "%s\n" "x-amz-date:${DateISO8601}"
    [ -z "${STSToken}" ] || printf "%s\n" "x-amz-security-token:${STSToken}"
  }

  LawsStdoutCanonicalHeader() {
    LawsStdoutHeader | sort
  }

  LawsStdoutCanonicalRequest() {
    printf "%s\n" "${HTTPMethod}" # GET
    printf "%s\n" "${RequestPath}" # /your-backet
    printf "%s\n" "${CanonicalQueryString}" # list-type=2&prefix=%2Fpath%2Fto%2Ffile
    printf "%s\n" "$(LawsStdoutCanonicalHeader)"
    printf "%s\n" "" # blank lines are required
    printf "%s\n" "$(LawsStdoutCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//')"
    printf "%s\n" "${HashedPayload}"
  }

  LawsStdoutStringtoSign() {
    printf "%s\n" "AWS4-HMAC-SHA256"
    printf "%s\n" "${DateISO8601}"
    printf "%s\n" "${DateYMD}/$(LawsStdoutRegion)/s3/aws4_request"
    printf "%s\n" "$(ConvertSHA256Hash "$(LawsStdoutCanonicalRequest)")"
  }

  LawsStdoutSignature() {
    ConvertHMAC "$(
      ConvertHMAC "$(
        ConvertHMAC "$(
          ConvertHMAC "$(
            ConvertHMAC "$(
              ConvertHex "AWS4${SecretAccessKey}"
            )" "${DateYMD}"
          )" "$(LawsStdoutRegion)"
        )" "s3"
      )" "aws4_request"
    )" "$(LawsStdoutStringtoSign)"
  }

  LawsStdoutAuthorization() {
    printf '%s' "AWS4-HMAC-SHA256"
    printf '%s' " Credential=${AccessKeyId}/${DateYMD}/$(LawsStdoutRegion)/s3/aws4_request,"
    printf '%s' " SignedHeaders=$(LawsStdoutCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//'),"
    printf '%s' " Signature=$(LawsStdoutSignature)"
  }

  LawsStdoutCallAPIS3Get() {
    curl -ksS -X "${HTTPMethod}" \
      -H "$(LawsStdoutCanonicalHeader)" \
      -H "Authorization: $(LawsStdoutAuthorization)" \
      "https://${APIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")"
  }

  LawsStdoutList() {
    # declare vars for methods
    HTTPMethod="GET"
    HashedPayload="$(ConvertSHA256Hash "")"

    # check sub commands
    case "$1" in
      /|"") # when no argument OR $1 = "/"
        RequestPath="/"
        CanonicalQueryString=""
        response=$(LawsStdoutCallAPIS3Get)
        # check error
        if ContainRegex '</Error>' "${response}"; then
          echo "${response}" >/dev/stderr
          return 1
        fi
        echo "${response}" | grep -Eo "[^>]*</Name><CreationDate>[^<]*" | sed 's|\([^>]*\)</Name><CreationDate>\([^<]*\)|\2 \1|g;'
        ;;

      *)
        # vars common
        sourcePath="$(PrintSchemeSlashSlashRemoved "$1")"

        # declare vars for methods
        RequestPath="/$(PrintExtractedHTTPHost "${sourcePath}")"
        if [ -z "${MaxKeys}" ] || ContainRegex "[^0-9]" "${MaxKeys}"; then MaxKeys=1000; fi
        Prefix=$(CommonStdoutUriEncoded "$(PrintExtractedHTTPPath "$1")")
        CanonicalQueryString="$([ -z "${ContinuationToken}" ] || printf '%s' "continuation-token=${ContinuationToken}&")list-type=2&max-keys=${MaxKeys}$([ -z "${Prefix}" ] || printf '%s' "&prefix=${Prefix}")"

        # run
        response=$(LawsStdoutCallAPIS3Get)

        # if error
        if ContainRegex '</Error>' "${response}"; then
          # if exist PermanentRedirect, declare new APIEndpoint and run LawsStdoutList
          if ContainRegex "<Code>PermanentRedirect</Code>" "${response}"; then
            APIEndpoint=$(PrintExtractedXMLValue "Endpoint" "${response}")
            LawsStdoutList "$@"
          fi

          # print error to stderr
          echo "${response}" >/dev/stderr
          return 1
        fi

        # display edited response
        if ContainRegex "[^>]*</Key><LastModified>[^<]*" "${response}"; then
          PrintExtractedByPattern "[^>]*</Key><LastModified>[^<]*" "${response}" | sed 's|\([^>]*\)</Key><LastModified>\([^<]*\)|\2 '"$(PrintExtractedHTTPHost "$1")"'/\1|g'
        else
          echo "${response}" > /dev/stderr
        fi

        # if exist NextContinuationToken, declare ContinuationToken and run LawsStdoutList
        if ContainRegex "<NextContinuationToken>[^<]*" "${response}"; then
          ContinuationToken=$(CommonStdoutUriEncoded "$(PrintExtractedXMLValue "NextContinuationToken" "${response}")")
          LawsStdoutList "$@"
        fi
        ;;
    esac
  }

  LawsStdoutGet() {
    # vars common
    sourcePath="$(PrintSchemeSlashSlashRemoved "${1:?"$(PrintErrLog F "LawsStdoutGet(): requires \"sourcePath\" as \$1")"}")"

    # vars for methods
    HTTPMethod="GET"
    HashedPayload="$(ConvertSHA256Hash "")"
    RequestPath="/$(CommonStdoutUriEncodedWithoutSlash "${sourcePath}")"
    CanonicalQueryString=""

    # run
    tmpFile=$(mktemp)
    LawsStdoutCallAPIS3Get > "${tmpFile}"
    response=$(cat "${tmpFile}")

    # error or not
    if ContainRegex '</Error>' "${response}"; then
      if ContainRegex "<Code>PermanentRedirect</Code>" "${response}"; then
        APIEndpoint=$(PrintExtractedXMLValue "Endpoint" "${response}")
        LawsStdoutGet "$@"
      fi

      # print error to stderr
      echo "${response}" >/dev/stderr
      return 1
    fi

    # if empty file, remove
    [ ! -s "${tmpFile}" ] || cat "${tmpFile}"
  }

  LawsSubCommandLs() {
    # if args contain "-h" or "--help" or "help" or ..., display README
    if ContainHelpOption "$*"; then PrintErrReadMe; exit 0; fi

    # if no args, list buckets, else list objects by passed bucket
    if [ "$#" = 0 ]; then
      LawsStdoutList
    else 
      for arg in "$@"; do
        LawsStdoutList "${arg}"
      done
    fi
  }

  LawsSubCommandCat() {
    # if 0 arg OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" = 0 ] || ContainHelpOption "$*"; then PrintErrReadMe; exit 0; fi

    # loop by the number of arguments.
    for arg in "$@"; do
      LawsStdoutGet "${arg}"
    done
  }

  LawsSubCommandCopy() {
    # if less than 2 args OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" != 2 ] || ContainHelpOption "$*"; then PrintErrReadMe; exit 0; fi

    # vars common
    sourcePath="$(PrintSchemeSlashSlashRemoved "${1:?"$(PrintErrLog F "LawsSubCommandCopy(): requires \"sourcePath\" as \$1")"}")"
    destinationPath="$(PrintSchemeSlashSlashRemoved "${2:?"$(PrintErrLog F "LawsSubCommandCopy(): requires \"destinationPath\" as \$2")"}")"

    # vars about bucket
    responseListBucket=$(LawsStdoutList)
    destinationBucketExist=$(echo "${responseListBucket}" | sed 's/^[^[:blank:]]*[[:blank:]]//' | grep "^$(PrintExtractedHTTPHost "${destinationPath}")$" ||:)

    # vars about path
    responseListPath=$(LawsSubCommandLs "${sourcePath}" "${destinationPath}" 2>/dev/null ||:)
    sourcePathExist=$(echo "${responseListPath}" | grep -E "[^[:blank:]][[:blank:]]${sourcePath}$" ||:)

    # copy local to s3 (PUT)
    if [ -e "${sourcePath}" ] && [ "${destinationBucketExist}" ]; then

      # vars for cURL
      HTTPMethod="PUT"
      HashedPayload="$(openssl dgst -sha256 "${sourcePath}" | sed 's/^.*[[:blank:]]//')"
      RequestPath="/$(CommonStdoutUriEncodedWithoutSlash "${destinationPath}")"
      CanonicalQueryString=""

      # Call API
      response=$(
        curl -ksS -X "${HTTPMethod}" \
          -H "$(LawsStdoutHeader)" \
          -H "Authorization: $(LawsStdoutAuthorization)" \
          -T "${sourcePath}" \
          "https://${APIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")" | tee /dev/stderr
      )

      if ContainRegex '</Error>' "${response}"; then
        return 1
      fi

      PrintErrLog I "uploaded ${sourcePath} to ${destinationPath}"

    # copy s3 to s3 (GET and PUT)
    elif [ "${sourcePathExist}" ] && [ "${destinationBucketExist}" ]; then
      # GET
      tmpFileForS3ToS3=$(mktemp)
      LawsStdoutGet "${sourcePath}" > "${tmpFileForS3ToS3}"

      # PUT
      response=$(LawsSubCommandCopy "${tmpFileForS3ToS3}" "${destinationPath}" 2>&1)

      # If the tmp file can be uploaded, output the appropriate log.
      if ContainRegex "uploaded.*${destinationPath}" "${response}"; then
        PrintErrLog I "uploaded ${sourcePath} to ${destinationPath}"
      # Otherwise, it outputs the original response.
      else
        echo "${response}" > /dev/stderr
      fi

    # copy s3 to local (GET)
    elif [ "${sourcePathExist}" ]; then

      if [ -d "${destinationPath}" ]; then
        LawsStdoutGet "${sourcePath}" > "${destinationPath}/$(basename -- "${sourcePath}")"
        PrintErrLog I "downloaded ${sourcePath} to ${destinationPath}/$(basename -- "${sourcePath}")"
      elif [ ! -d "${destinationPath}" ] && [ -d "$(dirname "${destinationPath}")" ]; then
        LawsStdoutGet "${sourcePath}" > "${destinationPath}"
        PrintErrLog I "downloaded ${sourcePath} to ${destinationPath}"
      else
        PrintErrLog E "not exist destination parent directory: \"$(dirname "${destinationPath}")\" OR already exist directory: \"${destinationPath}/$(basename -- "${sourcePath}\"")"
        return 1
      fi

    else
      PrintErrLog W "\"${sourcePath}\" and \"${destinationPath}\" not found or local files."
      return 1
    fi
  }

  LawsSubCommandS3() {
    # check sub commands
    case "$1" in
       ls) shift; LawsSubCommandLs "$@" ;;
      cat) shift; LawsSubCommandCat "$@" ;;
       cp) shift; LawsSubCommandCopy "$@" ;;
        *) PrintErrReadMe; exit 0 ;;
    esac
  }

  main() {
    # check dependency
    CheckDependency '[' cat curl date grep od openssl printf sed tr

    # display version
    if ContainRegex '-V|\-*version' "$*"; then
      echo "${PROGRAM_NAME} ${VERSION}"
    fi

    # declare vars for methods
    DateYMD=$(date +'%Y%m%d')
    DateISO8601=$(TZ=GMT date +'%Y%m%dT%H%M%SZ')
    APIEndpoint=$(LawsStdoutAPIEndpoint s3 "$(LawsStdoutRegion)")
    LawsSetAccessKey

    # check sub commands
    case "$1" in
      s3) shift && LawsSubCommandS3 "$@" ;;
       *) PrintErrReadMe; exit 0 ;;
    esac
  }

  #
  # Execute the main function.
  # It is executed first in this script.
  #
  # $@ ... Pass all the arguments of the laws command.
  #
  # e.g.
  #   main s3 ls s3://mybucket/path/tp/file
  main "$@"

else

  #
  # Interactive: laws as completion
  # ref: https://blog.cybozu.io/entry/2016/09/26/080000
  #
  # The following functions are for shell-completion.
  # When executing as a laws command,
  # the following functions are not defined nor executed.
  #
  # shellcheck disable=SC2016,SC2034,SC2039
  _laws() {
    local cur prev cword
    _get_comp_words_by_ref -n : cur prev cword
    if [ "${cword}" -eq 1 ]; then
      eval 'COMPREPLY=( $(compgen -W "s3" -- "${cur}") )'
    elif [ "${cword}" -eq 2 ]; then
      if [ "${prev}" = "s3" ]; then
        eval 'COMPREPLY=( $(compgen -W "ls cat cp" -- "${cur}") )'
      fi
    elif [ "${cword}" -eq 3 ] && { [ "${prev}" = 'ls' ] || [ "${prev}" = 'cat' ]; }; then
      if [ -z "${__laws_s3_ls_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_ls_completion_previous_execution_time)) -gt 30 ]; then
        __laws_s3_ls_completion_previous_execution_time=$(date +%s)
        __laws_s3_ls_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
      fi
      eval 'COMPREPLY=( $(compgen -W "${__laws_s3_ls_completion_previous_execution}" -- "${cur}") )'
    else
      # Cache the execution result of the command for 30 seconds.
      if [ -z "${__laws_s3_cp_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_cp_completion_previous_execution_time)) -gt 30 ]; then
        __laws_s3_cp_completion_previous_execution_time=$(date +%s)
        __laws_s3_cp_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
      fi
      eval 'COMPREPLY=( $(compgen -W "${__laws_s3_cp_completion_previous_execution} $(ls -aCdF "${cur}"* 2>/dev/null)" -- "${cur}") )'
    fi
  }
  # shellcheck disable=SC2039
  [ -z "$(command -v complete)" ] || complete -F _laws laws

fi

#!/bin/sh
# shellcheck disable=SC1117

# TODO: Make more readable.

if ! echo "$-" | grep -q i; then

  #
  # Non-interactive: execute laws as command
  #

  set -eo pipefail

  readonly VERSION="0.1.1"
  readonly PROGRAM_NAME="$(basename -- "$0")"

  # when exit,
  trap '[ ! -f "${tmpFile}" ] || rm -f ${tmpFile}; [ ! -f "${tmpFileForS3ToS3}" ] || rm -f ${tmpFileForS3ToS3}; ' EXIT

  LawsStdoutReadMe() (
  cat <<"README" >/dev/stderr

laws
====

Lightweight shell script for Amazon Web Service Command Line Interface like AWS CLI.


## TL;DR

    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls s3://your-bucket/prefix
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cat s3://your-bucket/path/to/file
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cp s3://your-bucket/path/to/file /path/to/file


## Install:

    sudo curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws -o /usr/local/bin/laws && sudo chmod +x $_


## Usage:

When executing this script,
  - Please use it on EC2 which has IAM Role allowed access to Amazon S3,
  - or save `~/.aws/config` and `~/.aws/credentials`,
  - or set the following environment variables:

    ```
    $ export AWS_REGION=ap-northeast-1
    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
    ```


#### `help`
Display help.  

    $ laws help


#### `s3 ls`
List the contents on Amazon S3.  

    $ laws s3 ls [<your-bucket>[<prefix>]]


#### `s3 cat`
Get the contents of the file on Amazon S3.  

    $ laws s3 cat s3://your-bucket/path/to/file ...


#### `s3 cp`
Copy a file.  

    $ laws s3 cp s3://your-bucket/path/to/file /path/to/file
    $ laws s3 cp /path/to/file s3://your-bucket/path/to/file
    $ laws s3 cp s3://your-bucket-b/path/to/file s3://your-bucket-a/path/to/file


#### completion
Tab Completion.

    $ . $(command -v laws)

OR  

    $ . /path/to/laws


## Note:
This program relies heavily on "AWS Signature Version 4".  

#### References:
  - Signing AWS Requests with Signature Version 4 - Amazon Web Services  
    https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html  
  - Authenticating Requests: Using Query Parameters (AWS Signature Version 4)
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  - Signature Calculations for the Authorization Header:  
    Transferring Payload in a Single Chunk (AWS Signature Version 4) - Amazon Simple Storage Service  
    https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html  
  - GET Bucket (List Objects) Version 2  
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html  
;
README
  return 0
  )

  CommonStdoutDateUTC() (
    LANG=C TZ=UTC date +"%Y%m%dT%H%M%SZ"
  )

  CommonStdoutLog() (
    level=${1:?"[FATAL] CommonStdoutLog(): requires \"level\" as \$1"}
    logMessages=${2:?"[FATAL] CommonStdoutLog(): requires \"logMessages\" as \$2"}
    case "${level}" in
      f|F) tag="[FATAL]" ;;
      e|E) tag="[ERROR]" ;;
      w|W) tag="[WARN] " ;;
        *) tag="[INFO] " ;;
    esac
    printf "%s\n" "${logMessages}" | sed "s/^/$(CommonStdoutDateUTC) ${PROGRAM_NAME}[$$]: ${tag} /" >/dev/stderr
  )

  CommonContainingMultiBytesChar() (
    contents="$1"
    echo "${contents}" | LANG=C grep -Evq '^[[:cntrl:][:print:]]*$'
  )

  CommonContainingRegex() (
    pattern="${1:?"[FATAL] CommonContainingRegex(): requires \"pattern\" as \$1"}"
    contents="$2"
    if echo "${contents}" | grep -Eq -- "${pattern}"; then
      return 0
    fi
    return 1
  )

  CommonContainingHelpOption() (
    CommonContainingRegex "^[[:blank:]]*\-+h(elp)?[[:blank:]]*|[[:blank:]]+\-+h(elp)?[[:blank:]]*$|^[[:blank:]]*help[[:blank:]]*$" "$*"
  )

  CommonCheckDependency() (
    for cmd in "$@"; do
      if ! command -v -- "${cmd}" >/dev/null; then
        CommonStdoutLog E "CommonCheckDependency(): \"${cmd}\" not found in PATH=\"${PATH}\""
        # If command not found in PATH, it terminates abnormally immediately.
        exit 1
      fi
    done
  ); CommonCheckDependency '[' cat curl date grep od openssl printf sed tr

  CommonStdoutParsedINI() (
    # For the setting in the ini file, output commands which define them as shell variables prefixed "INI_".
    iniSectionPattern="${1:?"[FATAL] CommonStdoutParsedINI(): requires \"iniSectionPattern\" as \$1"}"
    file=${2:?"[FATAL] CommonStdoutParsedINI(): requires \"file\" as \$2"}
    sed "s/[[:blank:]]*\=[[:blank:]]*/=/g; s/[#;].*$//; s/[[:blank:]]*$//; s/^[[:blank:]]*//; s/^\(.*\)=\([^\"\']*\)$/INI_\1=\"\2\"/" "${file}" \
      | sed -n "/^\[${iniSectionPattern}\]/,/\[/{/.*\=.*/p;}"
  )

  CommonStdoutHex() (
    printf "%s" "$1" | od -v -A n -t x1 | tr -Cd '0123456789abcdefABCDEF'
  )

  CommonStdoutHMAC() (
    printf "%s" "$2" | openssl dgst -sha256 -mac HMAC -macopt hexkey:"$1" | sed 's/^.* //'
  )

  CommonStdoutSHA256Hash() (
    printf "%s" "$1" | openssl dgst -sha256 | sed 's/^.* //'
  )

  CommonStdoutSchemeAndSlashSlashRemoved() (
    printf "%s" "$1" | sed 's|^[^:]*://||'
  )

  CommonStdoutExtractedByPattern() (
    pattern="${1:?"[FATAL] CommonStdoutExtractedByPattern(): requires \"pattern\" as \$1"}"
    contents="${2:?"[FATAL] CommonStdoutExtractedByPattern(): requires \"contents\" as \$2"}"
    echo "${contents}" | grep -Eo -- "${pattern}"
  )

  CommonStdoutExtractedXMLValue() (
    tagName="${1:?"[FATAL] CommonStdoutExtractedXMLValue(): requires \"tagName\" as \$1"}"
    contents="${2:?"[FATAL] CommonStdoutExtractedXMLValue(): requires \"contents\" as \$2"}"
    echo "${contents}" | grep -Eo "<${tagName}>.*</${tagName}>" | sed "s|</*${tagName}>||g"
  )

  CommonStdoutExtractedHTTPHost() {
    CommonStdoutSchemeAndSlashSlashRemoved "$1" | sed 's|/.*||'
  }

  CommonStdoutExtractedHTTPPath() {
    CommonStdoutSchemeAndSlashSlashRemoved "$1" | grep '/' | sed 's|^[^/]*/||'
  }

  CommonStdoutUriEncoded() {
    contents="$1"
    if CommonContainingMultiBytesChar "${contents}"; then
      CommonStdoutLog E "containing multi bytes char"
      # If multi-byte characters are included, abnormal termination immediately.
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        [[:alnum:].~_-])
          printf "%s" "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  }

  CommonStdoutUriEncodedWithoutSlash() {
    contents="$1"
    if CommonContainingMultiBytesChar "${contents}"; then
      CommonStdoutLog E "containing multi bytes char"
      # If multi-byte characters are included, abnormal termination immediately.
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        /|[[:alnum:].~_-])
          printf "%s" "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  }

  LawsStdoutRegion() (
    # 1. environment variable: AWS_REGION
    [ -z "${AWS_REGION}" ] || { echo "${AWS_REGION}"; return 0; }

    # 2. config file: ~/.aws/config
    if [ -r ~/.aws/config ]; then
      INI_region=""
      eval "$(CommonStdoutParsedINI "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/config)"
      if [ "${INI_region}" ]; then
        echo "${INI_region}"
        return 0
      else
        CommonStdoutLog W "LawsStdoutRegion(): Failed to parse ~/.aws/config: AWS_PROFILE=${AWS_PROFILE:-default}"
      fi
    fi

    # 3. meta-data
    if ! curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.$//'; then
      CommonStdoutLog E "$(cat <<"ERROR"

LawsStdoutRegion(): Not specified AWS Region
Follow the steps below to register AWS region:

1. Save config as: ~/.aws/config

    [default]
    region = ap-northeast-1

 ** OR **

1. Set environment variables:

    $ export AWS_REGION=ap-northeast-1
;
ERROR
      )"
      # If a region is not specified, abnormally terminates immediately.
      exit 1
    fi
  )

  LawsStdoutAPIEndpoint() (
    [ -z "${APIEndpoint}" ] || { echo "${APIEndpoint}"; return 0; }
    service="${1:?"[FATAL] LawsStdoutAPIEndpoint(): requires \"service\" as \$1"}"
    region="${2:?"[FATAL] LawsStdoutAPIEndpoint(): requires \"region\" as \$2"}"
    case "${service}" in
      s3) [ "${region}" = us-east-1 ] && echo "s3.amazonaws.com" || echo "s3-${region}.amazonaws.com" ;;
       *) CommonStdoutLog E "${service} not support"; return 1 ;;
    esac
  )

  LawsSetAccessKey() {
    # get credentials from environment variables
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ "${AWS_ACCESS_KEY_ID}" ] && [ "${AWS_SECRET_ACCESS_KEY}" ]; then
        AccessKeyId=${AWS_ACCESS_KEY_ID} SecretAccessKey=${AWS_SECRET_ACCESS_KEY}
      fi
    fi

    # get credentials from `~/.aws/config` and `~/.aws/credentials`
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ -r ~/.aws/credentials ]; then
        INI_aws_access_key_id="" INI_aws_secret_access_key=""
        eval "$(CommonStdoutParsedINI "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/credentials)"
        AccessKeyId="${INI_aws_access_key_id}" SecretAccessKey="${INI_aws_secret_access_key}"
        if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
          CommonStdoutLog W "LawsSetAccessKey(): Failed to parse ~/.aws/credentials: AWS_PROFILE=${AWS_PROFILE:-default}"
        fi
      fi
    fi

    # get credentials from Instance Profile
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      instanceProfile=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || :)
      secCredJSON=$(curl -sS --max-time 1 "http://169.254.169.254/latest/meta-data/iam/security-credentials/${instanceProfile}" 2>/dev/null ||:)
      AccessKeyId=$(echo "${secCredJSON}" | grep "AccessKeyId" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      SecretAccessKey=$(echo "${secCredJSON}" | grep "SecretAccessKey" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      STSToken=$(echo "${secCredJSON}" | grep "Token" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')

      # if STSToken is null, regarding as not running on EC2.
      if [ -z "${STSToken}" ]; then
        CommonStdoutLog E "$(cat <<"ERROR"

LawsSetAccessKey(): Failed to connect http://169.254.169.254/
Follow the steps below to register your credentials:

1. Save credentials file as: ~/.aws/credentials

    [default]
    aws_access_key_id = AKIA****************
    aws_secret_access_key = ****************************************

 ** OR **

1. Set environment variables:

    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
;
ERROR
        )"
      # If the secret key can not be acquired, the abnormal end immediately.
      exit 1
      fi
    fi
  }

  LawsStdoutHeader() {
    printf "%s\n" "host:${APIEndpoint}"
    [ "${HTTPMethod}" != PUT ] || printf "%s\n" "content-type:text/plain" # PUT
    printf "%s\n" "x-amz-content-sha256:${HashedPayload}"
    printf "%s\n" "x-amz-date:${DateISO8601}"
    [ -z "${STSToken}" ] || printf "%s\n" "x-amz-security-token:${STSToken}"
  }

  LawsStdoutCanonicalHeader() {
    LawsStdoutHeader | sort
  }

  LawsStdoutCanonicalRequest() {
    printf "%s\n" "${HTTPMethod}" # GET
    printf "%s\n" "${RequestPath}" # /your-backet
    printf "%s\n" "${CanonicalQueryString}" # list-type=2&prefix=%2Fpath%2Fto%2Ffile
    printf "%s\n" "$(LawsStdoutCanonicalHeader)"
    printf "%s\n" "" # blank lines are required
    printf "%s\n" "$(LawsStdoutCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//')"
    printf "%s\n" "${HashedPayload}"
  }

  LawsStdoutStringtoSign() {
    printf "%s\n" "AWS4-HMAC-SHA256"
    printf "%s\n" "${DateISO8601}"
    printf "%s\n" "${DateYMD}/$(LawsStdoutRegion)/s3/aws4_request"
    printf "%s\n" "$(CommonStdoutSHA256Hash "$(LawsStdoutCanonicalRequest)")"
  }

  LawsStdoutSignature() {
    CommonStdoutHMAC "$(
      CommonStdoutHMAC "$(
        CommonStdoutHMAC "$(
          CommonStdoutHMAC "$(
            CommonStdoutHMAC "$(
              CommonStdoutHex "AWS4${SecretAccessKey}"
            )" "${DateYMD}"
          )" "$(LawsStdoutRegion)"
        )" "s3"
      )" "aws4_request"
    )" "$(LawsStdoutStringtoSign)"
  }

  LawsStdoutAuthorization() {
    printf "%s" "AWS4-HMAC-SHA256"
    printf "%s" " Credential=${AccessKeyId}/${DateYMD}/$(LawsStdoutRegion)/s3/aws4_request,"
    printf "%s" " SignedHeaders=$(LawsStdoutCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//'),"
    printf "%s" " Signature=$(LawsStdoutSignature)"
  }

  LawsStdoutCallAPIS3Get() {
    curl -ksS -X "${HTTPMethod}" \
      -H "$(LawsStdoutCanonicalHeader)" \
      -H "Authorization: $(LawsStdoutAuthorization)" \
      "https://${APIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")"
  }

  LawsStdoutList() {
    # declare vars for methods
    HTTPMethod="GET"
    HashedPayload="$(CommonStdoutSHA256Hash "")"

    # check sub commands
    case "$1" in
      "") # when $# = 0
        RequestPath="/"
        CanonicalQueryString=""
        response=$(LawsStdoutCallAPIS3Get)
        # check error
        if CommonContainingRegex "</Error>" "${response}"; then
          echo "${response}" >/dev/stderr
          return 1
        fi
        echo "${response}" | grep -Eo "[^>]*</Name><CreationDate>[^<]*" | sed 's|\([^>]*\)</Name><CreationDate>\([^<]*\)|\2 \1|g;'
        ;;

      *)
        # declare vars for methods
        RequestPath="/$(CommonStdoutExtractedHTTPHost "$1")"
        if [ -z "${MaxKeys}" ] || CommonContainingRegex "[^0-9]" "${MaxKeys}"; then MaxKeys=1000; fi
        Prefix=$(CommonStdoutUriEncoded "$(CommonStdoutExtractedHTTPPath "$1")")
        CanonicalQueryString="$([ -z "${ContinuationToken}" ] || printf "%s" "continuation-token=${ContinuationToken}&")list-type=2&max-keys=${MaxKeys}$([ -z "${Prefix}" ] || printf "%s" "&prefix=${Prefix}")"

        # run
        response=$(LawsStdoutCallAPIS3Get)

        # if error
        if CommonContainingRegex "</Error>" "${response}"; then
          # if exist PermanentRedirect, declare new APIEndpoint and run LawsStdoutList
          if CommonContainingRegex "<Code>PermanentRedirect</Code>" "${response}"; then
            APIEndpoint=$(CommonStdoutExtractedXMLValue "Endpoint" "${response}")
            LawsStdoutList "$@"
          fi

          # print error to stderr
          echo "${response}" >/dev/stderr
          return 1
        fi

        # display edited response
        CommonStdoutExtractedByPattern "[^>]*</Key><LastModified>[^<]*" "${response}" | sed 's|\([^>]*\)</Key><LastModified>\([^<]*\)|\2 '"$(CommonStdoutExtractedHTTPHost "$1")"'/\1|g'

        # if exist NextContinuationToken, declare ContinuationToken and run LawsStdoutList
        if CommonContainingRegex "<NextContinuationToken>[^<]*" "${response}"; then
          ContinuationToken=$(CommonStdoutUriEncoded "$(CommonStdoutExtractedXMLValue "NextContinuationToken" "${response}")")
          LawsStdoutList "$@"
        fi
        ;;
    esac
  }

  LawsStdoutGet() {
    # declare vars for methods
    HTTPMethod="GET"
    HashedPayload="$(CommonStdoutSHA256Hash "")"
    RequestPath="/$(CommonStdoutUriEncodedWithoutSlash "$(CommonStdoutSchemeAndSlashSlashRemoved "$1")")"
    CanonicalQueryString=""

    # run
    tmpFile=$(mktemp)
    LawsStdoutCallAPIS3Get > "${tmpFile}"
    response=$(cat "${tmpFile}")

    # error or not
    if CommonContainingRegex "</Error>" "${response}"; then
      if CommonContainingRegex "<Code>PermanentRedirect</Code>" "${response}"; then
        APIEndpoint=$(CommonStdoutExtractedXMLValue "Endpoint" "${response}")
        LawsStdoutGet "$@"
      fi

      # print error to stderr
      echo "${response}" >/dev/stderr
      return 1
    fi

    # if empty file, remove
    [ ! -s "${tmpFile}" ] || cat "${tmpFile}"
  }

  LawsSubCommandLs() {
    # if args contain "-h" or "--help" or "help" or ..., display README
    if CommonContainingHelpOption "$*"; then LawsStdoutReadMe; fi

    # if no args, list buckets, else list objects by passed bucket
    if [ "$#" = 0 ]; then
      LawsStdoutList
    else 
      for arg in "$@"; do
        LawsStdoutList "${arg}"
      done
    fi
  }

  LawsSubCommandCat() {
    # if 0 arg OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" = 0 ] || CommonContainingHelpOption "$*"; then LawsStdoutReadMe; fi

    # loop by the number of arguments.
    for arg in "$@"; do
      LawsStdoutGet "${arg}"
    done
  }

  LawsSubCommandCopy() {
    # if less than 2 args OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" != 2 ] || CommonContainingHelpOption "$*"; then LawsStdoutReadMe; fi

    # vars
    sourcePath="${1:?"[FATAL] LawsSubCommandCopy(): requires \"sourcePath\" as \$1"}"
    destinationPath="${2:?"[FATAL] LawsSubCommandCopy(): requires \"destinationPath\" as \$2"}"
    responseListBucket=$(LawsStdoutList)
    sourceBucketExist=$(echo "${responseListBucket}" | sed 's/^[^[:blank:]]*[[:blank:]]//' | grep "^$(CommonStdoutExtractedHTTPHost "${sourcePath}")$" ||:)
    destinationBucketExist=$(echo "${responseListBucket}" | sed 's/^[^[:blank:]]*[[:blank:]]//' | grep "^$(CommonStdoutExtractedHTTPHost "${destinationPath}")$" ||:)

    # copy local to s3
    if [ -e "${sourcePath}" ] && [ "${destinationBucketExist}" ]; then

      HTTPMethod="PUT"
      HashedPayload="$(openssl dgst -sha256 "${sourcePath}" | sed 's/^.* //')"
      RequestPath="/$(CommonStdoutUriEncodedWithoutSlash "$(CommonStdoutSchemeAndSlashSlashRemoved "$2")")"
      CanonicalQueryString=""

      response=$(
        curl -ksS -X "${HTTPMethod}" \
          -H "$(LawsStdoutHeader)" \
          -H "Authorization: $(LawsStdoutAuthorization)" \
          -T "${sourcePath}" \
          "https://${APIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")" | tee /dev/stderr
      )

      if CommonContainingRegex "</Error>" "${response}"; then
        return 1
      fi

      CommonStdoutLog I "uploaded ${sourcePath} to ${destinationPath}"

    elif [ "${sourceBucketExist}" ] && [ "${destinationBucketExist}" ]; then

      tmpFileForS3ToS3=$(mktemp)
      LawsStdoutGet "${sourcePath}" > "${tmpFileForS3ToS3}"
      response=$(LawsSubCommandCopy "${tmpFileForS3ToS3}" "${destinationPath}" 2>&1)

      # If the tmp file can be uploaded, output the appropriate log.
      if CommonContainingRegex "uploaded.*${destinationPath}" "${response}"; then
        CommonStdoutLog I "uploaded ${sourcePath} to ${destinationPath}"
      # Otherwise, it outputs the original response.
      else
        echo "${response}" > /dev/stderr
      fi

    # copy s3 to local (GET)
    elif [ "${sourceBucketExist}" ]; then

      if [ -d "$(dirname "${destinationPath}")" ] && [ -d "${destinationPath}" ]; then
        LawsStdoutGet "${sourcePath}" > "${destinationPath}/$(basename -- "${sourcePath}")"
      elif [ -d "$(dirname "${destinationPath}")" ] && [ ! -d "${destinationPath}" ]; then
        LawsStdoutGet "${sourcePath}" > "${destinationPath}"
      else
        CommonStdoutLog E "not exist destination parent directory: \"$(dirname "${destinationPath}")\" OR already exist directory: \"${destinationPath}/$(basename -- "${sourcePath}\"")"
        return 1
      fi

      CommonStdoutLog I "downloaded ${sourcePath} to ${destinationPath}"

    else

      CommonStdoutLog W "Both \"${sourcePath}\" and \"${destinationPath}\" are local files."
      return 1

    fi

  }

  LawsSubCommandS3() {
    # check sub commands
    case "$1" in
       ls) shift; LawsSubCommandLs "$@" ;;
      cat) shift; LawsSubCommandCat "$@" ;;
       cp) shift; LawsSubCommandCopy "$@" ;;
        *) LawsStdoutReadMe ;;
    esac
  }

  main() {
    # display version
    if CommonContainingRegex "-V|\-*version" "$*"; then
      echo "${PROGRAM_NAME} ${VERSION}"
      return 0
    fi

    # declare vars for methods
    DateYMD=$(date +'%Y%m%d')
    DateISO8601=$(TZ=GMT date +'%Y%m%dT%H%M%SZ')
    APIEndpoint=$(LawsStdoutAPIEndpoint s3 "$(LawsStdoutRegion)")
    LawsSetAccessKey

    # check sub commands
    case "$1" in
      s3) shift && LawsSubCommandS3 "$@" ;;
       *) LawsStdoutReadMe ;;
    esac
  }

  #
  # Execute the main function.
  # It is executed first in this script.
  #
  # $@ ... Pass all the arguments of the laws command.
  #
  # e.g.
  #   main s3 ls s3://mybucket/path/tp/file
  main "$@"

else

  #
  # Interactive: laws as completion
  # ref: https://blog.cybozu.io/entry/2016/09/26/080000
  #
  # The following functions are for shell-completion.
  # When executing as a laws command,
  # the following functions are not defined nor executed.
  #
  # shellcheck disable=SC2016,SC2034,SC2039
  _laws() {
    local cur prev cword
    _get_comp_words_by_ref -n : cur prev cword
    if [ "${cword}" -eq 1 ]; then
      eval 'COMPREPLY=( $(compgen -W "s3" -- "${cur}") )'
    elif [ "${cword}" -eq 2 ]; then
      if [ "${prev}" = "s3" ]; then
        eval 'COMPREPLY=( $(compgen -W "ls cat cp" -- "${cur}") )'
      fi
    elif [ "${cword}" -eq 3 ]; then
      if [ "${prev}" = "ls" ] || [ "${prev}" = "cat" ]; then
        if [ -z "${__laws_s3_ls_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_ls_completion_previous_execution_time)) -gt 30 ]; then
          __laws_s3_ls_completion_previous_execution_time=$(date +%s)
          __laws_s3_ls_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
        fi
        eval 'COMPREPLY=( $(compgen -W "${__laws_s3_ls_completion_previous_execution}" -- "${cur}") )'
      elif [ "${prev}" = "cp" ]; then
        # Cache the execution result of the command for 30 seconds.
        if [ -z "${__laws_s3_cp_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_cp_completion_previous_execution_time)) -gt 30 ]; then
          __laws_s3_cp_completion_previous_execution_time=$(date +%s)
          __laws_s3_cp_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ') $(ls -d ./* ./.*)"
        fi
        eval 'COMPREPLY=( $(compgen -W "${__laws_s3_cp_completion_previous_execution}" -- "${cur}") )'
      fi
    fi
  }
  # shellcheck disable=SC2039
  [ -z "$(command -v complete)" ] || complete -F _laws laws

fi

#!/bin/sh
# shellcheck disable=SC1117

# TODO: make more readable.

# If in non interactive shell ( "$-" not containing "i" ), execute "laws" as command.
if ! { echo "$-" | grep -q 'i'; }; then

  # If an error occurs, terminate abnormally.
  set -e

  # Global variables
  readonly VERSION='0.1.4'
  readonly PROGRAM_NAME="$(basename -- "$0")"

  # When exiting, clean up temporary files.
  trap '
    if [ -f "${tmpFile}" ]; then
      rm -f ${tmpFile}
    fi
    if [ -f "${tmpFileForS3ToS3}" ]; then
      rm -f ${tmpFileForS3ToS3}
    fi' EXIT

  ##
  # Output README
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   string README
  # Return:
  #   0 always
  ##
  PrintErrReadMe() { (
  cat <<'README' >/dev/stderr

laws
====

Lightweight shell script for Amazon Web Service Command Line Interface like AWS CLI.


## TL;DR

    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls s3://your-bucket/prefix
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cat s3://your-bucket/path/to/file
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cp s3://your-bucket/path/to/file /path/to/file


## Install:

    sudo curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws -o /usr/local/bin/laws && sudo chmod +x $_


## Usage:

When executing this script,
  - Please use it on EC2 which has IAM Role allowed access to Amazon S3,
  - or save `~/.aws/config` and `~/.aws/credentials`,
  - or set the following environment variables:

    ```
    $ export AWS_REGION=ap-northeast-1
    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
    ```


#### `help`
Display help.  

    $ laws help


#### `s3 ls`
List the contents on Amazon S3.  

    $ laws s3 ls [<your-bucket>[<prefix>]]


#### `s3 cat`
Get the contents of the file on Amazon S3.  

    $ laws s3 cat s3://your-bucket/path/to/file ...


#### `s3 cp`
Copy a file.  

    $ laws s3 cp s3://your-bucket/path/to/file /path/to/file
    $ laws s3 cp /path/to/file s3://your-bucket/path/to/file
    $ laws s3 cp s3://your-bucket-b/path/to/file s3://your-bucket-a/path/to/file


#### completion
Tab Completion.

    $ . $(command -v laws)

OR  

    $ . /path/to/laws


## Note:
This program relies heavily on "AWS Signature Version 4".  

#### References:
  - Signing AWS Requests with Signature Version 4 - Amazon Web Services  
    https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html  
  - Authenticating Requests: Using Query Parameters (AWS Signature Version 4)
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  - Signature Calculations for the Authorization Header:  
    Transferring Payload in a Single Chunk (AWS Signature Version 4) - Amazon Simple Storage Service  
    https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html  
  - GET Bucket (List Objects) Version 2  
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html  

---
README
  )}

  ##
  # Output UTC date for log
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   string UTC date ISO 8601 format
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintDateUTC() { (
    LANG=C TZ=UTC date +'%Y%m%dT%H%M%SZ'
  )}

  ##
  # Output log
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 log level
  #   $2 log message
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   string log message
  # Return:
  #   0 always
  ##
  PrintErrLog() { (
    # vars
    level="${1:?"$(PrintDateUTC) [FATAL] PrintErrLog(): requires \"level\" as \$1"}"
    logMessages="${2:?"$(PrintDateUTC) [FATAL] PrintErrLog(): requires \"logMessages\" as \$2"}"
    
    # check level
    case "${level}" in
      f|F) tag='[FATAL]' ;;
      e|E) tag='[ERROR]' ;;
      w|W) tag='[WARN] ' ;;
        *) tag='[INFO] ' ;;
    esac

    # output log message to stderr
    printf '%s\n' "${logMessages}" | sed "s/^/$(PrintDateUTC) ${PROGRAM_NAME}[$$]: ${tag} /" >/dev/stderr
  )}

  ##
  # Check containing multi bytes character
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 content to be checked
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 containing
  #   1 NOT containing
  ##
  ContainMultiBytesChar() { (
    # Local vars
    data="$1"

    # Check containing
    echo "${data}" | LANG=C grep -Evq '^[[:cntrl:][:print:]]*$'
  )}

  ##
  # Check containing regex passed
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 regex pattern
  #   $2 content to be checked by pattern
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 containing
  #   1 NOT containing
  ##
  ContainRegex() { (
    # Local vars
    pattern="${1:?"$(PrintErrLog F "ContainRegex(): requires \"pattern\" as \$1")"}"
    data="$2"

    # Check containing
    echo "${data}" | grep -Eq -- "${pattern}"
  )}

  ##
  # Check containing "-h" or "--help" or "help"
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 regex pattern
  #   $2 content to be checked containing help option
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 containing
  #   1 NOT containing
  ##
  ContainHelpOption() { (
    #                  "-h" "--help"           "a -h b" "a --help b"  "help"
    ContainRegex '^[[:blank:]]*\-+h(elp)?|[[:blank:]]+\-+h(elp)?|^[[:blank:]]*help[[:blank:]]*$' "$*"
  )}

  ##
  # Check existing dependency commands in PATH
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $@ commands
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 exist
  #   1 NOT exist, EXIT immediately
  ##
  CheckDependency() { (
    for cmd in "$@"; do
      if ! { command -v -- "${cmd}" >/dev/null; }; then
        PrintErrLog E "CheckDependency(): \"${cmd}\" not found in PATH=\"${PATH}\""
        # If command not found in PATH, it terminates abnormally immediately.
        exit 1
      fi
    done
  )}

  ##
  # Parse INI file and Print stdout
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 ini file pattern like "[foobar]"
  #   $2 ini file path
  # Stdin:
  #   no
  # Stdout:
  #   string rarsed ini content as shell vars
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ParseINIforEval() { (
    # For the setting in the ini file, output commands which define them as shell variables prefixed "INI_".
    iniSectionPattern="${1:?"$(PrintErrLog F "ParseINIforEval(): requires \"iniSectionPattern\" as \$1")"}"
    file="${2:?"$(PrintErrLog F "ParseINIforEval(): requires \"file\" as \$2")"}"
    sed "
      s/[[:blank:]]*\=[[:blank:]]*/=/g
      s/[#;].*$//
      s/[[:blank:]]*$//
      s/^[[:blank:]]*//
      s/^\(.*\)=\([^\"\']*\)$/INI_\1=\"\2\"/
      " "${file}" \
      | sed -n "/^\[${iniSectionPattern}\]/,/\[/{/.*\=.*/p;}"
  )}

  ##
  # Convert hexadecimal
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 content converted to hexadecimal
  # Stdin:
  #   no
  # Stdout:
  #   string converted hexadecimal data
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ConvertHex() { (
    printf '%s' "$1" | od -v -A n -t x1 | tr -Cd '0123456789abcdefABCDEF'
  )}

  ##
  # Convert $2 (sha256 HMAC) by $1
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 HEXADECIMAL key
  #   $2 data be converted
  # Stdin:
  #   no
  # Stdout:
  #   string converted data
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ConvertHMAC() { (
    printf '%s' "$2" | openssl dgst -sha256 -mac HMAC -macopt hexkey:"$1" | sed 's/^.*[[:blank:]]//'
  )}

  ##
  # Convert $1 by sha256
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 data
  # Stdin:
  #   no
  # Stdout:
  #   string converted data
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  ConvertSHA256Hash() { (
    printf '%s' "$1" | openssl dgst -sha256 | sed 's/^.*[[:blank:]]//'
  )}

  ##
  # Print string scheme+slash+slash ( like http:// https:// s3:// ssh:// ... ) removed
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 data
  # Stdin:
  #   no
  # Stdout:
  #   string removed "s3://"
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintSchemeSlashSlashRemoved() { (
    printf '%s' "$1" | sed 's|^[^:]*://||'
  )}

  ##
  # Print string extracted by pattern
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 data
  # Stdin:
  #   no
  # Stdout:
  #   string extracted by pattern
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedByPattern() { (
    pattern="${1:?"$(PrintErrLog F "PrintExtractedByPattern(): requires \"pattern\" as \$1")"}"
    data="${2:?"$(PrintErrLog F "PrintExtractedByPattern(): requires \"data\" as \$2")"}"
    echo "${data}" | grep -Eo -- "${pattern}"
  )}

  ##
  # Print string extracted XML value
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 XML tag
  #   $2 extracted data
  # Stdin:
  #   no
  # Stdout:
  #   string extracted by XML tag
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedXMLValue() { (
    tagName="${1:?"$(PrintErrLog F "PrintExtractedXMLValue(): requires \"tagName\" as \$1")"}"
    data="${2:?"$(PrintErrLog F "PrintExtractedXMLValue(): requires \"data\" as \$2")"}"
    echo "${data}" | grep -Eo "<${tagName}>.*</${tagName}>" | sed "s|</?${tagName}>||g"
  )}

  ##
  # Print string extracted HTTP host
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 uri
  # Stdin:
  #   no
  # Stdout:
  #   string extracted host
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedHTTPHost() { (
    PrintSchemeSlashSlashRemoved "$1" | sed 's|/.*||'
  )}

  ##
  # Print string extracted HTTP path
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 uri
  # Stdin:
  #   no
  # Stdout:
  #   string extracted path
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintExtractedHTTPPath() { (
    PrintSchemeSlashSlashRemoved "$1" | grep '/' | sed 's|^[^/]*/||'
  )}

  ##
  # Encode uri string
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 uri
  # Stdin:
  #   no
  # Stdout:
  #   string uri encoded
  # Stderr:
  #   no
  # Return:
  #   0 success to encode
  #   1 ContainMultiBytesChar, EXIT immediately
  ##
  EncodeUri() { (
    data="$1"
    if ContainMultiBytesChar "${data}"; then
      PrintErrLog E 'containing multi bytes char'
      # If multi-byte characters are included, abnormal termination immediately.
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        [0-9A-Za-z._~-])
          printf '%s' "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  )}

  ##
  # Encode uri string without slash /
  # EnvironmentVariables:
  #   no
  # Arguments:
  #   $1 uri
  # Stdin:
  #   no
  # Stdout:
  #   string uri encoded
  # Stderr:
  #   no
  # Return:
  #   0 success to encode uri
  #   1 ContainMultiBytesChar, EXIT immediately
  ##
  EncodeUriWithoutSlash() { (
    data="$1"
    if ContainMultiBytesChar "${data}"; then
      PrintErrLog E 'containing multi bytes char'
      # If multi-byte characters are included, abnormal termination immediately.
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        [/0-9A-Za-z._~-])
          printf '%s' "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  )}

  ##
  # Print "AWS Region" aquired by Environment Variable "AWS_REGION" OR "~/.aws/config" OR "169.254.169.254"
  # EnvironmentVariables:
  #   AWS_REGION option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   string AWS Region
  # Stderr:
  #   no
  # Return:
  #   0 Print AWS Region
  #   1 when failed to get AWS Region
  ##
  PrintAWSRegion() { (
    # 1. environment variable: AWS_REGION
    [ -z "${AWS_REGION}" ] || { echo "${AWS_REGION}"; return 0; }

    # 2. config file: ~/.aws/config
    if [ -r ~/.aws/config ]; then
      INI_region=''
      eval "$(ParseINIforEval "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/config)"
      if [ "${INI_region}" ]; then
        echo "${INI_region}"
      else
        PrintErrLog W "PrintAWSRegion(): Failed to parse ~/.aws/config: AWS_PROFILE=${AWS_PROFILE:-default}"
      fi
    fi

    # 3. meta-data
    if ! curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.$//'; then
      PrintErrLog E "$(cat <<'ERROR'

PrintAWSRegion(): Not specified AWS Region
Follow the steps below to register AWS region:

1. Save config as: ~/.aws/config

    [default]
    region = ap-northeast-1

 ** OR **

1. Set environment variables:

    $ export AWS_REGION=ap-northeast-1

---
ERROR
      )"
      # If a region is not specified, abnormally terminates immediately.
      exit 1
    fi
  )}

  ##
  # Print "AWS API Endpoint" aquired by Service Name AND AWS Region
  # If already "AWSAPIEndpoint" defined, return normally without doing anything
  # EnvironmentVariables:
  #   AWSAPIEndpoint option
  #   AWS_REGION option
  # Arguments:
  #   $1 Service Name
  #   $2 AWS Region
  # Stdin:
  #   no
  # Stdout:
  #   string AWS API Endpoint
  # Stderr:
  #   no
  # Return:
  #   0 print AWS API Endpoint
  #   1 when pass un-supported service
  ##
  PrintAWSAPIEndpoint() { (
    # If already "AWSAPIEndpoint" defined, return normally without doing anything
    [ -z "${AWSAPIEndpoint}" ] || { echo "${AWSAPIEndpoint}"; return 0; }
    # Local variables
    service="${1:?"$(PrintErrLog F "PrintAWSAPIEndpoint(): requires \"service\" as \$1")"}"
    region="${2:?"$(PrintErrLog F "PrintAWSAPIEndpoint(): requires \"region\" as \$2")"}"
    # switch by service
    case "${service}" in
      s3) [ "${region}" = us-east-1 ] && echo 's3.amazonaws.com' || echo "s3-${region}.amazonaws.com" ;;
       *) PrintErrLog E "${service} not support"; return 1 ;;
    esac
  )}

  ##
  # Set global variables AWSAccessKeyId AND AWSSecretAccessKey
  # If already "AWSAccessKeyId" AND "AWSSecretAccessKey" defined, return normally without doing anything
  # EnvironmentVariables:
  #   AWSAccessKeyId option
  #   AWSSecretAccessKey option
  #   AWS_ACCESS_KEY_ID option
  #   AWS_SECRET_ACCESS_KEY option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   no
  # Stderr:
  #   no
  # Return:
  #   0 set AWSAccessKeyId AND AWSSecretAccessKey
  #   1 EXIT immediately when failed to set AWSAccessKeyId AND AWSSecretAccessKey
  ##
  SetAWSAccessKey() {
    # If already "AWSAccessKeyId" AND "AWSSecretAccessKey" defined, return normally without doing anything
    if [ "${AWSAccessKeyId}" ] && [ "${AWSSecretAccessKey}" ]; then
      return 0
    fi

    # get credentials from environment variables
    if [ "${AWS_ACCESS_KEY_ID}" ] && [ "${AWS_SECRET_ACCESS_KEY}" ]; then
      AWSAccessKeyId="${AWS_ACCESS_KEY_ID}" AWSSecretAccessKey="${AWS_SECRET_ACCESS_KEY}"
      # If "AWSAccessKeyId" AND "AWSSecretAccessKey" defined, return normally
      if [ "${AWSAccessKeyId}" ] && [ "${AWSSecretAccessKey}" ]; then
        return 0
      fi
    fi

    # get credentials from `~/.aws/config` and `~/.aws/credentials`
    if [ -r ~/.aws/credentials ]; then
      INI_aws_access_key_id='' INI_aws_secret_access_key=''
      eval "$(ParseINIforEval "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/credentials)"
      AWSAccessKeyId="${INI_aws_access_key_id}" AWSSecretAccessKey="${INI_aws_secret_access_key}"
      # If "AWSAccessKeyId" AND "AWSSecretAccessKey" defined, return normally
      if [ "${AWSAccessKeyId}" ] && [ "${AWSSecretAccessKey}" ]; then
        return 0
      fi
    fi

    # get credentials from Instance Profile
    instanceProfile=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || true)
    secCredJSON=$(curl -sS --max-time 1 "http://169.254.169.254/latest/meta-data/iam/security-credentials/${instanceProfile}" 2>/dev/null || true)
    AWSAccessKeyId=$(echo "${secCredJSON}" | grep 'AccessKeyId' | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
    AWSSecretAccessKey=$(echo "${secCredJSON}" | grep 'SecretAccessKey' | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
    STSToken=$(echo "${secCredJSON}" | grep 'Token' | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')

    # if STSToken is null, regarding as not running on EC2.
    if [ "${AWSAccessKeyId}" ] && [ "${AWSSecretAccessKey}" ] && [ "${STSToken}" ]; then
      return 0
    fi

    # PrintErrLog and EXIT abnormally immediately
    PrintErrLog E "$(cat <<'ERROR'

SetAWSAccessKey(): Failed to connect http://169.254.169.254/
Follow the steps below to register your credentials:

1. Save credentials file as: ~/.aws/credentials

    [default]
    aws_access_key_id = AKIA****************
    aws_secret_access_key = ****************************************

 ** OR **

1. Set environment variables:

    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************

---
ERROR
    )"
    # If the secret key can not be acquired, EXIT abnormally immediately
    exit 1
  }

  ##
  # Print Header for Request to AWS API
  # EnvironmentVariables:
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   HashedPayload required
  #   DateISO8601 required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   HTTP header
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintHTTPHeader() { (
    printf '%s\n' "host:${AWSAPIEndpoint}"
    [ "${HTTPMethod}" != PUT ] || printf '%s\n' 'content-type:text/plain' # PUT
    printf '%s\n' "x-amz-content-sha256:${HashedPayload}"
    printf '%s\n' "x-amz-date:${DateISO8601}"
    [ -z "${STSToken}" ] || printf '%s\n' "x-amz-security-token:${STSToken}"
  )}

  ##
  # Print CanonicalHeader of AWS Signature Version 4
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  # EnvironmentVariables:
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   HashedPayload required
  #   DateISO8601 required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   sorted HTTP header
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintCanonicalHeader() { (
    PrintHTTPHeader | sort
  )}

  ##
  # Print CanonicalRequest of AWS Signature Version 4
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  # EnvironmentVariables:
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   RequestPath required
  #   CanonicalQueryString required
  #   HashedPayload required
  #   DateISO8601 required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   HTTP request
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintCanonicalRequest() { (
    printf '%s\n' "${HTTPMethod}"                # GET / PUT
    printf '%s\n' "${RequestPath}"               # /your-backet
    printf '%s\n' "${CanonicalQueryString}"      # list-type=2&prefix=%2Fpath%2Fto%2Ffile
    printf '%s\n' "$(PrintCanonicalHeader)" # 
    printf '%s\n' ''                             # blank lines are required
    printf '%s\n' "$(PrintCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//')"
    printf '%s\n' "${HashedPayload}"
  )}

  ##
  # Print StringToSign of AWS Signature Version 4
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  # EnvironmentVariables:
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   RequestPath required
  #   CanonicalQueryString required
  #   HashedPayload required
  #   DateISO8601 required
  #   DateYMD required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   StringToSign
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintStringtoSign() { (
    printf '%s\n' 'AWS4-HMAC-SHA256'
    printf '%s\n' "${DateISO8601}"
    printf '%s\n' "${DateYMD}/$(PrintAWSRegion)/s3/aws4_request"
    printf '%s\n' "$(ConvertSHA256Hash "$(PrintCanonicalRequest)")"
  )}

  ##
  # Print Signature of AWS Signature Version 4
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  # EnvironmentVariables:
  #   AWSSecretAccessKey required
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   RequestPath required
  #   CanonicalQueryString required
  #   HashedPayload required
  #   DateISO8601 required
  #   DateYMD required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   Signature
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintSignature() { (
    ConvertHMAC "$(
      ConvertHMAC "$(
        ConvertHMAC "$(
          ConvertHMAC "$(
            ConvertHMAC "$(
              ConvertHex "AWS4${AWSSecretAccessKey}"
            )" "${DateYMD}"
          )" "$(PrintAWSRegion)"
        )" 's3'
      )" 'aws4_request'
    )" "$(PrintStringtoSign)"
  )}

  ##
  # Print Authorization of AWS Signature Version 4
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  # EnvironmentVariables:
  #   AWSSecretAccessKey required
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   RequestPath required
  #   CanonicalQueryString required
  #   HashedPayload required
  #   DateISO8601 required
  #   DateYMD required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   Signature
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  LawsStdoutAuthorization() { (
    printf '%s' 'AWS4-HMAC-SHA256'
    printf '%s' " Credential=${AWSAccessKeyId}/${DateYMD}/$(PrintAWSRegion)/s3/aws4_request,"
    printf '%s' " SignedHeaders=$(PrintCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//'),"
    printf '%s' " Signature=$(PrintSignature)"
  )}

  ##
  # Call S3 API GET
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/RESTObjectGET.html
  # EnvironmentVariables:
  #   AWSSecretAccessKey required
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   RequestPath required
  #   CanonicalQueryString required
  #   HashedPayload required
  #   DateISO8601 required
  #   DateYMD required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   Signature
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  CallAPIS3GET() { (
    curl -ksS -X "${HTTPMethod}" \
      -H "$(PrintCanonicalHeader)" \
      -H "Authorization: $(LawsStdoutAuthorization)" \
      "https://${AWSAPIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")"
  )}

  ##
  # Call S3 API PUT
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/RESTObjectPUT.html
  # EnvironmentVariables:
  #   AWSSecretAccessKey required
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   RequestPath required
  #   CanonicalQueryString option
  #   HashedPayload required
  #   DateISO8601 required
  #   DateYMD required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   Signature
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  CallAPIS3PUT() { (
    curl -ksS -X "${HTTPMethod}" \
      -H "$(PrintHTTPHeader)" \
      -H "Authorization: $(LawsStdoutAuthorization)" \
      -T "${sourcePath}" \
      "https://${AWSAPIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")" | tee /dev/stderr
  )}

  ##
  # Print S3 List
  #   https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html
  # EnvironmentVariables:
  #   AWSSecretAccessKey required
  #   AWSAPIEndpoint required
  #   HTTPMethod required
  #   RequestPath required
  #   CanonicalQueryString required
  #   HashedPayload required
  #   DateISO8601 required
  #   DateYMD required
  #   STSToken option
  # Arguments:
  #   no
  # Stdin:
  #   no
  # Stdout:
  #   Signature
  # Stderr:
  #   no
  # Return:
  #   0 always
  ##
  PrintS3List() {
    # declare vars for methods
    HTTPMethod='GET'
    HashedPayload="$(ConvertSHA256Hash '')"

    # check options
    case "$1" in
      /|'') # when no argument OR $1 = "/"
        # vars
        RequestPath='/'
        CanonicalQueryString=''
        response=$(CallAPIS3GET)

        # If err != nil
        if ContainRegex '</Error>' "${response}"; then
          echo "${response}" >/dev/stderr
          return 1
        fi

        # exit normally
        echo "${response}" | grep -Eo '[^>]*</Name><CreationDate>[^<]*' | sed 's|\([^>]*\)</Name><CreationDate>\([^<]*\)|\2 \1|g;'
        ;;

      *)
        # vars
        s3Path="$(PrintSchemeSlashSlashRemoved "$1")"

        # declare vars for methods
        RequestPath="/$(PrintExtractedHTTPHost "${s3Path}")"
        if [ -z "${MaxKeys}" ] || ContainRegex '[^0-9]' "${MaxKeys}"; then MaxKeys=1000; fi
        Prefix=$(EncodeUri "$(PrintExtractedHTTPPath "$1")")
        CanonicalQueryString="$([ -z "${ContinuationToken}" ] || printf '%s' "continuation-token=${ContinuationToken}&")list-type=2&max-keys=${MaxKeys}$([ -z "${Prefix}" ] || printf '%s' "&prefix=${Prefix}")"

        # run
        response=$(CallAPIS3GET)

        # if error
        if ContainRegex '</Error>' "${response}"; then
          # if exist PermanentRedirect, declare new AWSAPIEndpoint and run PrintS3List
          if ContainRegex '<Code>PermanentRedirect</Code>' "${response}"; then
            AWSAPIEndpoint=$(PrintExtractedXMLValue 'Endpoint' "${response}")
            PrintS3List "$@"
          fi

          # print error to stderr
          echo "${response}" >/dev/stderr
          return 1
        fi

        # display edited response
        if ContainRegex '[^>]*</Key><LastModified>[^<]*' "${response}"; then
          PrintExtractedByPattern '[^>]*</Key><LastModified>[^<]*' "${response}" | sed 's|\([^>]*\)</Key><LastModified>\([^<]*\)|\2 '"$(PrintExtractedHTTPHost "$1")"'/\1|g'
        else
          echo "${response}" > /dev/stderr
        fi

        # if exist NextContinuationToken, declare ContinuationToken and run PrintS3List
        if ContainRegex '<NextContinuationToken>[^<]*' "${response}"; then
          ContinuationToken=$(EncodeUri "$(PrintExtractedXMLValue 'NextContinuationToken' "${response}")")
          PrintS3List "$@"
        fi
        ;;
    esac
  }

  LawsStdoutGet() {
    # vars common
    s3Path="$(PrintSchemeSlashSlashRemoved "${1:?"$(PrintErrLog F "LawsStdoutGet(): requires \"s3Path\" as \$1")"}")"

    # vars for methods
    HTTPMethod='GET'
    HashedPayload="$(ConvertSHA256Hash '')"
    RequestPath="/$(EncodeUriWithoutSlash "${s3Path}")"
    CanonicalQueryString=''

    # run
    tmpFile=$(mktemp)
    CallAPIS3GET > "${tmpFile}"
    response=$(cat "${tmpFile}")

    # error or not
    if ContainRegex '</Error>' "${response}"; then
      if ContainRegex '<Code>PermanentRedirect</Code>' "${response}"; then
        AWSAPIEndpoint=$(PrintExtractedXMLValue 'Endpoint' "${response}")
        LawsStdoutGet "$@"
      fi

      # print error to stderr
      echo "${response}" >/dev/stderr
      return 1
    fi

    # if empty file, remove
    [ ! -s "${tmpFile}" ] || cat "${tmpFile}"
  }

  LawsSubCommandLs() {
    # if args contain "-h" or "--help" or "help" or ..., display README
    if ContainHelpOption "$*"; then PrintErrReadMe; exit 0; fi

    # if no args, list buckets, else list objects by passed bucket
    if [ "$#" = 0 ]; then
      PrintS3List
    else 
      for arg in "$@"; do
        PrintS3List "${arg}"
      done
    fi
  }

  LawsSubCommandCat() {
    # if 0 arg OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" = 0 ] || ContainHelpOption "$*"; then PrintErrReadMe; exit 0; fi

    # loop by the number of arguments.
    for arg in "$@"; do
      LawsStdoutGet "${arg}"
    done
  }

  LawsSubCommandCopy() {
    # if less than 2 args OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" != 2 ] || ContainHelpOption "$*"; then PrintErrReadMe; exit 0; fi

    # vars common
    sourcePath="$(PrintSchemeSlashSlashRemoved "${1:?"$(PrintErrLog F "LawsSubCommandCopy(): requires \"sourcePath\" as \$1")"}")"
    destinationPath="$(PrintSchemeSlashSlashRemoved "${2:?"$(PrintErrLog F "LawsSubCommandCopy(): requires \"destinationPath\" as \$2")"}")"

    # vars about bucket
    responseListBucket=$(PrintS3List)
    destinationBucketExist=$(echo "${responseListBucket}" | sed 's/^[^[:blank:]]*[[:blank:]]//' | grep "^$(PrintExtractedHTTPHost "${destinationPath}")$" || true)

    # vars about path
    responseListPath=$(LawsSubCommandLs "${sourcePath}" "${destinationPath}" 2>/dev/null || true)
    sourcePathExist=$(echo "${responseListPath}" | grep -E "[^[:blank:]][[:blank:]]${sourcePath}$" || true)

    # copy local to s3 (PUT)
    if [ -e "${sourcePath}" ] && [ "${destinationBucketExist}" ]; then

      # vars for cURL
      HTTPMethod='PUT'
      HashedPayload="$(openssl dgst -sha256 "${sourcePath}" | sed 's/^.*[[:blank:]]//')"
      RequestPath="/$(EncodeUriWithoutSlash "${destinationPath}")"
      CanonicalQueryString=''

      # Call API
      response=$(CallAPIS3PUT)

      if ContainRegex '</Error>' "${response}"; then
        return 1
      fi

      PrintErrLog I "uploaded ${sourcePath} to ${destinationPath}"

    # copy s3 to s3 (GET and PUT)
    elif [ "${sourcePathExist}" ] && [ "${destinationBucketExist}" ]; then
      # GET
      tmpFileForS3ToS3=$(mktemp)
      LawsStdoutGet "${sourcePath}" > "${tmpFileForS3ToS3}"

      # PUT
      response=$(LawsSubCommandCopy "${tmpFileForS3ToS3}" "${destinationPath}" 2>&1)

      # If the tmp file can be uploaded, output the appropriate log.
      if ContainRegex "uploaded.*${destinationPath}" "${response}"; then
        PrintErrLog I "uploaded ${sourcePath} to ${destinationPath}"
      # Otherwise, it outputs the original response.
      else
        echo "${response}" > /dev/stderr
      fi

    # copy s3 to local (GET)
    elif [ "${sourcePathExist}" ]; then

      if [ -d "${destinationPath}" ]; then
        LawsStdoutGet "${sourcePath}" > "${destinationPath}/$(basename -- "${sourcePath}")"
        PrintErrLog I "downloaded ${sourcePath} to ${destinationPath}/$(basename -- "${sourcePath}")"
      elif [ ! -d "${destinationPath}" ] && [ -d "$(dirname "${destinationPath}")" ]; then
        LawsStdoutGet "${sourcePath}" > "${destinationPath}"
        PrintErrLog I "downloaded ${sourcePath} to ${destinationPath}"
      else
        PrintErrLog E "not exist destination parent directory: \"$(dirname "${destinationPath}")\" OR already exist directory: \"${destinationPath}/$(basename -- "${sourcePath}\"")"
        return 1
      fi

    else
      PrintErrLog W "\"${sourcePath}\" and \"${destinationPath}\" not found or local files."
      return 1
    fi
  }

  LawsSubCommandS3() {
    # check sub commands
    case "$1" in
       ls) shift; LawsSubCommandLs "$@" ;;
      cat) shift; LawsSubCommandCat "$@" ;;
       cp) shift; LawsSubCommandCopy "$@" ;;
        *) PrintErrReadMe; exit 0 ;;
    esac
  }

  main() {
    # check dependency
    CheckDependency '[' cat curl date grep od openssl printf sed tr

    # display version
    if ContainRegex '-V|\-*version' "$*"; then
      echo "${PROGRAM_NAME} ${VERSION}"
    fi

    # declare vars for methods
    DateYMD=$(date +'%Y%m%d')
    DateISO8601=$(TZ=GMT date +'%Y%m%dT%H%M%SZ')
    AWSAPIEndpoint=$(PrintAWSAPIEndpoint s3 "$(PrintAWSRegion)")
    SetAWSAccessKey

    # check sub commands
    case "$1" in
      s3) shift && LawsSubCommandS3 "$@" ;;
       *) PrintErrReadMe; exit 0 ;;
    esac
  }

  #
  # Execute the main function.
  # It is executed first in this script.
  #
  # $@ ... Pass all the arguments of the laws command.
  #
  # e.g.
  #   main s3 ls s3://mybucket/path/tp/file
  main "$@"

else

  #
  # Interactive: laws as completion
  # ref: https://blog.cybozu.io/entry/2016/09/26/080000
  #
  # The following functions are for shell-completion.
  # When executing as a laws command,
  # the following functions are not defined nor executed.
  #
  # shellcheck disable=SC2016,SC2034,SC2039
  _laws() {
    local cur prev cword
    _get_comp_words_by_ref -n : cur prev cword
    if [ "${cword}" -eq 1 ]; then
      eval 'COMPREPLY=( $(compgen -W "s3" -- "${cur}") )'
    elif [ "${cword}" -eq 2 ]; then
      if [ "${prev}" = 's3' ]; then
        eval 'COMPREPLY=( $(compgen -W "ls cat cp" -- "${cur}") )'
      fi
    elif [ "${cword}" -eq 3 ] && { [ "${prev}" = 'ls' ] || [ "${prev}" = 'cat' ]; }; then
      if [ -z "${__laws_s3_ls_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_ls_completion_previous_execution_time)) -gt 30 ]; then
        __laws_s3_ls_completion_previous_execution_time=$(date +%s)
        __laws_s3_ls_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
      fi
      eval 'COMPREPLY=( $(compgen -W "${__laws_s3_ls_completion_previous_execution}" -- "${cur}") )'
    else
      # Cache the execution result of the command for 30 seconds.
      if [ -z "${__laws_s3_cp_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_cp_completion_previous_execution_time)) -gt 30 ]; then
        __laws_s3_cp_completion_previous_execution_time=$(date +%s)
        __laws_s3_cp_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
      fi
      eval 'COMPREPLY=( $(compgen -W "${__laws_s3_cp_completion_previous_execution} $(ls -aCdF "${cur}"* 2>/dev/null)" -- "${cur}") )'
    fi
  }
  # shellcheck disable=SC2039
  [ -z "$(command -v complete)" ] || complete -F _laws laws

fi

#!/bin/sh
# shellcheck disable=SC1117

if ! echo "$-" | grep -q i; then

  #
  # Non-interactive: execute laws as command
  #

  set -e

  readonly VERSION="0.0.12"
  readonly PROGRAM_NAME="$(basename -- "$0")"

  LawsStdoutReadMe() (
  cat <<"README" >/dev/stderr

laws
====

Lightweight shell script for Amazon Web Service Command Line Interface like AWS CLI.


## TL;DR

    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls s3://your-bucket/prefix
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cat s3://your-bucket/path/to/file
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cp s3://your-bucket/path/to/file /path/to/file


## Install:

    sudo curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws -o /usr/local/bin/laws && sudo chmod +x $_


## Usage:

When executing this script,
  - Please use it on EC2 which has IAM Role allowed access to Amazon S3,
  - or save `~/.aws/config` and `~/.aws/credentials`,
  - or set the following environment variables:

    ```
    $ export AWS_REGION=ap-northeast-1
    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
    ```


#### `help`
Display help.  

    $ laws help


#### `s3 ls`
List the contents on Amazon S3.  

    $ laws s3 ls [<your-bucket>[<prefix>]]


#### `s3 cat`
Get the contents of the file on Amazon S3.  

    $ laws s3 cat s3://your-bucket/path/to/file ...


#### `s3 cp`
Copy a file.  

    $ laws s3 cp s3://your-bucket/path/to/file /path/to/file
    $ (unimplemented) laws s3 cp /path/to/file s3://your-bucket/path/to/file
    $ (unimplemented) laws s3 cp s3://your-bucket-b/path/to/file s3://your-bucket-a/path/to/file


#### completion
Tab Completion.

    $ . $(command -v laws)

OR  

    $ . /path/to/laws


## Note:
This program relies heavily on "AWS Signature Version 4".  

#### References:
  - Signing AWS Requests with Signature Version 4 - Amazon Web Services  
    https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html  
  - Authenticating Requests: Using Query Parameters (AWS Signature Version 4)
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  - Signature Calculations for the Authorization Header:  
    Transferring Payload in a Single Chunk (AWS Signature Version 4) - Amazon Simple Storage Service  
    https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html  
  - GET Bucket (List Objects) Version 2  
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html  
;
README
  return 0
  )

  CommonStdoutDateUTC() (
    LANG=C TZ=UTC date +"%Y%m%dT%H%M%SZ"
  )

  CommonStdoutLog() (
    level=${1:?"[FATAL] CommonStdoutLog(): requires \"level\" as \$1"}
    logMessages=${2:?"[FATAL] CommonStdoutLog(): requires \"logMessages\" as \$2"}
    case "${level}" in
      f|F) tag="[FATAL]" ;;
      e|E) tag="[ERROR]" ;;
      w|W) tag="[WARN] " ;;
        *) tag="[INFO] " ;;
    esac
    printf "%s\n" "${logMessages}" | sed "s/^/$(CommonStdoutDateUTC) ${PROGRAM_NAME}[$$]: ${tag} /" >/dev/stderr
  )

  CommonContainingMultiBytesChar() (
    contents="$1"
    echo "${contents}" | LANG=C grep -Evq '^[[:cntrl:][:print:]]*$'
  )

  CommonContainingRegex() (
    pattern="${1:?"[FATAL] CommonContainingRegex(): requires \"pattern\" as \$1"}"
    contents="$2"
    if echo "${contents}" | grep -Eq -- "${pattern}"; then
      return 0
    fi
    return 1
  )

  CommonContainingHelpOption() (
    CommonContainingRegex "^[[:blank:]]*\-+h(elp)?[[:blank:]]*|[[:blank:]]+\-+h(elp)?[[:blank:]]*$|^[[:blank:]]*help[[:blank:]]*$" "$*"
  )

  CommonCheckDependency() (
    for cmd in "$@"; do
      if ! command -v -- "${cmd}" >/dev/null; then
        CommonStdoutLog E "CommonCheckDependency(): \"${cmd}\" not found in PATH=\"${PATH}\""
        exit 1
      fi
    done
  ); CommonCheckDependency '[' cat curl date grep od openssl printf sed tr

  CommonStdoutParsedINI() (
    # For the setting in the ini file, output commands which define them as shell variables prefixed "INI_".
    iniSectionPattern="${1:?"[FATAL] CommonStdoutParsedINI(): requires \"iniSectionPattern\" as \$1"}"
    file=${2:?"[FATAL] CommonStdoutParsedINI(): requires \"file\" as \$2"}
    sed "s/[[:blank:]]*\=[[:blank:]]*/=/g; s/[#;].*$//; s/[[:blank:]]*$//; s/^[[:blank:]]*//; s/^\(.*\)=\([^\"\']*\)$/INI_\1=\"\2\"/" "${file}" \
      | sed -n "/^\[${iniSectionPattern}\]/,/\[/{/.*\=.*/p;}"
  )

  CommonStdoutHex() (
    printf "%s" "$1" | od -v -A n -t x1 | tr -d '[:blank:]|\n'
  )

  CommonStdoutHMAC() (
    printf "%s" "$2" | openssl dgst -sha256 -mac HMAC -macopt hexkey:"$1" | sed 's/^.* //'
  )

  CommonStdoutSHA256Hash() (
    printf "%s" "$1" | openssl dgst -sha256 | sed 's/^.* //'
  )

  CommonStdoutSchemeAndSlashSlashRemoved() (
    printf "%s" "$1" | sed 's|^[^:]*://||'
  )

  CommonStdoutExtractedByPattern() (
    pattern="${1:?"[FATAL] CommonStdoutExtractedByPattern(): requires \"pattern\" as \$1"}"
    contents="${2:?"[FATAL] CommonStdoutExtractedByPattern(): requires \"contents\" as \$2"}"
    echo "${contents}" | grep -Eo -- "${pattern}"
  )

  CommonStdoutExtractedXMLValue() (
    tagName="${1:?"[FATAL] CommonStdoutExtractedXMLValue(): requires \"tagName\" as \$1"}"
    contents="${2:?"[FATAL] CommonStdoutExtractedXMLValue(): requires \"contents\" as \$2"}"
    echo "${contents}" | grep -Eo "<${tagName}>.*</${tagName}>" | sed "s|</*${tagName}>||g"
  )

  CommonStdoutExtractedHTTPHost() {
    CommonStdoutSchemeAndSlashSlashRemoved "$1" | sed 's|/.*||'
  }

  CommonStdoutExtractedHTTPPath() {
    CommonStdoutSchemeAndSlashSlashRemoved "$1" | grep '/' | sed 's|^[^/]*/||'
  }

  CommonStdoutUriEncoded() {
    contents="$1"
    if CommonContainingMultiBytesChar "${contents}"; then
      CommonStdoutLog E "containing multi bytes char"
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        [[:alnum:].~_-])
          printf "%s" "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  }

  CommonStdoutUriEncodedWithoutSlash() {
    contents="$1"
    if CommonContainingMultiBytesChar "${contents}"; then
      CommonStdoutLog E "containing multi bytes char"
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        /|[[:alnum:].~_-])
          printf "%s" "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  }

  LawsStdoutRegion() (
    # 1. environment variable: AWS_REGION
    [ -z "${AWS_REGION}" ] || { echo "${AWS_REGION}"; return 0; }

    # 2. config file: ~/.aws/config
    if [ -r ~/.aws/config ]; then
      INI_region=""
      eval "$(CommonStdoutParsedINI "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/config)"
      if [ "${INI_region}" ]; then
        echo "${INI_region}"
        return 0
      else
        CommonStdoutLog W "LawsStdoutRegion(): Failed to parse ~/.aws/config: AWS_PROFILE=${AWS_PROFILE:-default}"
      fi
    fi

    # 3. meta-data
    if ! curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.$//'; then
      CommonStdoutLog E "$(cat <<"ERROR"

LawsStdoutRegion(): Not specified AWS Region
Follow the steps below to register AWS region:

1. Save config as: ~/.aws/config

    [default]
    region = ap-northeast-1

 ** OR **

1. Set environment variables:

    $ export AWS_REGION=ap-northeast-1
;
ERROR
      )"
      exit 1
    fi
  )

  LawsStdoutAPIEndpoint() (
    [ -z "${APIEndpoint}" ] || { echo "${APIEndpoint}"; return 0; }
    service="${1:?"[FATAL] LawsStdoutAPIEndpoint(): requires \"service\" as \$1"}"
    region="${2:?"[FATAL] LawsStdoutAPIEndpoint(): requires \"region\" as \$2"}"
    case "${service}" in
      s3) [ "${region}" = us-east-1 ] && echo "s3.amazonaws.com" || echo "s3-${region}.amazonaws.com" ;;
       *) CommonStdoutLog E "${service} not support"; return 1 ;;
    esac
  )

  LawsSetAccessKey() {
    # get credentials from environment variables
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ "${AWS_ACCESS_KEY_ID}" ] && [ "${AWS_SECRET_ACCESS_KEY}" ]; then
        AccessKeyId=${AWS_ACCESS_KEY_ID} SecretAccessKey=${AWS_SECRET_ACCESS_KEY}
      fi
    fi

    # get credentials from `~/.aws/config` and `~/.aws/credentials`
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ -r ~/.aws/credentials ]; then
        INI_aws_access_key_id="" INI_aws_secret_access_key=""
        eval "$(CommonStdoutParsedINI "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/credentials)"
        AccessKeyId="${INI_aws_access_key_id}" SecretAccessKey="${INI_aws_secret_access_key}"
        if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
          CommonStdoutLog W "LawsSetAccessKey(): Failed to parse ~/.aws/credentials: AWS_PROFILE=${AWS_PROFILE:-default}"
        fi
      fi
    fi

    # get credentials from Instance Profile
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      instanceProfile=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || :)
      secCredJSON=$(curl -sS --max-time 1 "http://169.254.169.254/latest/meta-data/iam/security-credentials/${instanceProfile}" 2>/dev/null ||:)
      AccessKeyId=$(echo "${secCredJSON}" | grep "AccessKeyId" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      SecretAccessKey=$(echo "${secCredJSON}" | grep "SecretAccessKey" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      STSToken=$(echo "${secCredJSON}" | grep "Token" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')

      # if STSToken is null, regarding as not running on EC2.
      if [ -z "${STSToken}" ]; then
        CommonStdoutLog E "$(cat <<"ERROR"

LawsSetAccessKey(): Failed to connect http://169.254.169.254/
Follow the steps below to register your credentials:

1. Save credentials file as: ~/.aws/credentials

    [default]
    aws_access_key_id = AKIA****************
    aws_secret_access_key = ****************************************

 ** OR **

1. Set environment variables:

    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
;
ERROR
        )"
      exit 1
      fi
    fi
  }

  LawsStdoutCanonicalHeader() {
    printf "%s\n" "host:${APIEndpoint}"
    printf "%s\n" "x-amz-content-sha256:$(CommonStdoutSHA256Hash "${Payload}")"
    printf "%s\n" "x-amz-date:${DateISO8601}"
    [ -z "${STSToken}" ] || printf "%s\n" "x-amz-security-token:${STSToken}"
  }

  LawsStdoutCanonicalRequest() {
    printf "%s\n" "${HTTPMethod}" # GET
    printf "%s\n" "${RequestPath}" # /your-backet
    printf "%s\n" "${CanonicalQueryString}" # list-type=2&prefix=%2Fpath%2Fto%2Ffile
    printf "%s\n" "$(LawsStdoutCanonicalHeader)"
    printf "%s\n" "" # blank lines are required
    printf "%s\n" "$(LawsStdoutCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//')"
    printf "%s\n" "$(CommonStdoutSHA256Hash "${Payload}")"
  }

  LawsStdoutStringtoSign() {
    printf "%s\n" "AWS4-HMAC-SHA256"
    printf "%s\n" "${DateISO8601}"
    printf "%s\n" "${DateYMD}/$(LawsStdoutRegion)/s3/aws4_request"
    printf "%s\n" "$(CommonStdoutSHA256Hash "$(LawsStdoutCanonicalRequest)")"
  }

  LawsStdoutSignature() {
    CommonStdoutHMAC "$(
      CommonStdoutHMAC "$(
        CommonStdoutHMAC "$(
          CommonStdoutHMAC "$(
            CommonStdoutHMAC "$(
              CommonStdoutHex "AWS4${SecretAccessKey}"
            )" "${DateYMD}"
          )" "$(LawsStdoutRegion)"
        )" "s3"
      )" "aws4_request"
    )" "$(LawsStdoutStringtoSign)"
  }

  LawsStdoutAuthorization() {
    printf "%s" "AWS4-HMAC-SHA256"
    printf "%s" " Credential=${AccessKeyId}/${DateYMD}/$(LawsStdoutRegion)/s3/aws4_request,"
    printf "%s" " SignedHeaders=$(LawsStdoutCanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//'),"
    printf "%s" " Signature=$(LawsStdoutSignature)"
  }

  LawsStdoutCallAPIS3Get() {
    curl -ksS -X "${HTTPMethod}" \
      -H "$(LawsStdoutCanonicalHeader)" \
      -H "Authorization: $(LawsStdoutAuthorization)" \
      "https://${APIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")"
  }

  LawsStdoutList() {
    # check sub commands
    case "$1" in
      "") # when $# = 0
        RequestPath="/"
        CanonicalQueryString=""
        response=$(LawsStdoutCallAPIS3Get)
        # check error
        if CommonContainingRegex "</Error>" "${response}"; then
          echo "${response}" >/dev/stderr
          exit 1
        fi
        echo "${response}" | grep -Eo "[^>]*</Name><CreationDate>[^<]*" | sed 's|\([^>]*\)</Name><CreationDate>\([^<]*\)|\2 \1|g;'
        ;;

      *)
        # declare vars for methods
        RequestPath="/$(CommonStdoutExtractedHTTPHost "$1")"
        if [ -z "${MaxKeys}" ] || CommonContainingRegex "[^0-9]" "${MaxKeys}"; then MaxKeys=1000; fi
        Prefix=$(CommonStdoutUriEncoded "$(CommonStdoutExtractedHTTPPath "$1")")
        CanonicalQueryString="$([ -z "${ContinuationToken}" ] || printf "%s" "continuation-token=${ContinuationToken}&")list-type=2&max-keys=${MaxKeys}$([ -z "${Prefix}" ] || printf "%s" "&prefix=${Prefix}")"

        # run
        response=$(LawsStdoutCallAPIS3Get)

        # if error
        if CommonContainingRegex "</Error>" "${response}"; then
          # if exist PermanentRedirect, declare new APIEndpoint and run LawsStdoutList
          if CommonContainingRegex "<Code>PermanentRedirect</Code>" "${response}"; then
            APIEndpoint=$(CommonStdoutExtractedXMLValue "Endpoint" "${response}")
            LawsStdoutList "$@"
          fi

          # print error to stderr
          echo "${response}" >/dev/stderr
          exit 1
        fi

        # display edited response
        CommonStdoutExtractedByPattern "[^>]*</Key><LastModified>[^<]*" "${response}" | sed 's|\([^>]*\)</Key><LastModified>\([^<]*\)|\2 '"$(CommonStdoutExtractedHTTPHost "$1")"'/\1|g'

        # if exist NextContinuationToken, declare ContinuationToken and run LawsStdoutList
        if CommonContainingRegex "<NextContinuationToken>[^<]*" "${response}"; then
          ContinuationToken=$(CommonStdoutUriEncoded "$(CommonStdoutExtractedXMLValue "NextContinuationToken" "${response}")")
          LawsStdoutList "$@"
        fi
        ;;
    esac
  }

  LawsStdoutGet() {
    # declare vars for methods
    RequestPath="/$(CommonStdoutUriEncodedWithoutSlash "$(CommonStdoutSchemeAndSlashSlashRemoved "$1")")"
    CanonicalQueryString=""

    # run
    tmpFile=$(mktemp)
    LawsStdoutCallAPIS3Get > "${tmpFile}"
    response="$(cat "${tmpFile}")"

    # error or not
    if CommonContainingRegex "</Error>" "${response}"; then
      if CommonContainingRegex "<Code>PermanentRedirect</Code>" "${response}"; then
        APIEndpoint=$(CommonStdoutExtractedXMLValue "Endpoint" "${response}")
        LawsStdoutGet "$@"
      fi

      # print error to stderr
      echo "${response}" >/dev/stderr
      exit 1
    fi

    # if empty file, remove
    if [ -s "${tmpFile}" ]; then
      cat "${tmpFile}"
    else
      rm -f "${tmpFile}"
    fi
  }

  LawsSubCommandLs() {
    # if args contain "-h" or "--help" or "help" or ..., display README
    if CommonContainingHelpOption "$*"; then LawsStdoutReadMe; fi

    # if no args, list buckets, else list objects by passed bucket
    if [ "$#" = 0 ]; then
      LawsStdoutList
    else 
      for arg in "$@"; do
        LawsStdoutList "${arg}"
      done
    fi
  }

  LawsSubCommandCat() {
    # if 0 arg OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" = 0 ] || CommonContainingHelpOption "$*"; then LawsStdoutReadMe; fi

    # loop by the number of arguments.
    for arg in "$@"; do
      LawsStdoutGet "${arg}"
    done
  }

  LawsSubCommandCopy() {
    # if less than 2 args OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" -lt 2 ] || CommonContainingHelpOption "$*"; then LawsStdoutReadMe; fi

    # copy s3 to local
    if [ -r "$1" ] && [ ! -x "$2" ]; then
      CommonStdoutLog E "LawsSubCommandCopy(): cp ( src=S3 dest=local ) is unimplemented"
      exit 1
    fi

    # copy local to s3
    if [ ! -x "$1" ]; then
      if [ -d "$(dirname "$2")" ]; then
        LawsStdoutGet "$1" > "$2"
        exit 0
      fi
    fi
  }

  LawsSubCommandS3() {
    # check sub commands
    case "$1" in
       ls) shift; HTTPMethod="GET"; Payload=""; LawsSubCommandLs "$@" ;;
      cat) shift; HTTPMethod="GET"; Payload=""; LawsSubCommandCat "$@" ;;
       cp) shift && LawsSubCommandCopy "$@" ;;
        *) LawsStdoutReadMe ;;
    esac
  }

  main() {
    # display version
    if CommonContainingRegex "-V|\-*version" "$*"; then
      echo "${PROGRAM_NAME} ${VERSION}"
      exit 0
    fi

    # declare vars for methods
    DateYMD=$(date +'%Y%m%d')
    DateISO8601=$(TZ=GMT date +'%Y%m%dT%H%M%SZ')
    APIEndpoint=$(LawsStdoutAPIEndpoint s3 "$(LawsStdoutRegion)")
    LawsSetAccessKey

    # check sub commands
    case "$1" in
      s3) shift && LawsSubCommandS3 "$@" ;;
       *) LawsStdoutReadMe ;;
    esac
  }

  #
  # Execute the main function.
  # It is executed first in this script.
  #
  # $@ ... Pass all the arguments of the laws command.
  #
  # e.g.
  #   main s3 ls s3://mybucket/path/tp/file
  main "$@"

else

  #
  # Interactive: laws as completion
  # ref: https://blog.cybozu.io/entry/2016/09/26/080000
  #
  # The following functions are for shell-completion.
  # When executing as a laws command,
  # the following functions are not defined nor executed.
  #
  # shellcheck disable=SC2016,SC2034,SC2039
  _laws() {
    local cur prev cword
    _get_comp_words_by_ref -n : cur prev cword
    if [ "${cword}" -eq 1 ]; then
      eval 'COMPREPLY=( $(compgen -W "s3" -- "${cur}") )'
    elif [ "${cword}" -eq 2 ]; then
      if [ "${prev}" = "s3" ]; then
        eval 'COMPREPLY=( $(compgen -W "ls cat cp" -- "${cur}") )'
      fi
    elif [ "${cword}" -eq 3 ]; then
      if [ "${prev}" = "ls" ] || [ "${prev}" = "cat" ]; then
        if [ -z "${__laws_s3_ls_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_ls_completion_previous_execution_time)) -gt 30 ]; then
          __laws_s3_ls_completion_previous_execution_time=$(date +%s)
          __laws_s3_ls_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
        fi
        eval 'COMPREPLY=( $(compgen -W "${__laws_s3_ls_completion_previous_execution}" -- "${cur}") )'
      elif [ "${prev}" = "cp" ]; then
        # Cache the execution result of the command for 30 seconds.
        if [ -z "${__laws_s3_cp_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_s3_cp_completion_previous_execution_time)) -gt 30 ]; then
          __laws_s3_cp_completion_previous_execution_time=$(date +%s)
          __laws_s3_cp_completion_previous_execution="$(laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ') $(ls -d ./* ./.*)"
        fi
        eval 'COMPREPLY=( $(compgen -W "${__laws_s3_cp_completion_previous_execution}" -- "${cur}") )'
      fi
    fi
  }
  # shellcheck disable=SC2039
  [ -z "$(command -v complete)" ] || complete -F _laws laws

fi

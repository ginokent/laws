#!/bin/sh
# shellcheck disable=SC1117

if ! echo "$-" | grep -q i; then

  # Non-interactive: execute laws as command

  set -e

  readonly VERSION="0.0.9"
  readonly PROGRAM_NAME="$(basename -- "$0")"

  ReadMe() {
  cat <<"README" >/dev/stderr

laws
====

Lightweight shell script for Amazon Web Service Command Line Interface like AWS CLI.


## TL;DR

    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls s3://your-bucket/prefix
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cat s3://your-bucket/path/to/file
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cp s3://your-bucket/path/to/file /path/to/file


## Install:

    sudo curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws -o /usr/local/bin/laws && sudo chmod +x $_


## Usage:

When executing this script,
  - Please use it on EC2 which has IAM Role allowed access to Amazon S3,
  - or save `~/.aws/config` and `~/.aws/credentials`,
  - or set the following environment variables:

    ```
    $ export AWS_REGION=ap-northeast-1
    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
    ```


#### `help`
Display help.  

    $ laws help


#### `s3 ls`
List the contents on Amazon S3.  

    $ laws s3 ls [<your-bucket>[<prefix>]]


#### `s3 cat`
Get the contents of the file on Amazon S3.  

    $ laws s3 cat s3://your-bucket/path/to/file ...


#### `s3 cp`
Copy a file.  

    $ laws s3 cp s3://your-bucket/path/to/file /path/to/file
    $ (unimplemented) laws s3 cp /path/to/file s3://your-bucket/path/to/file
    $ (unimplemented) laws s3 cp s3://your-bucket-b/path/to/file s3://your-bucket-a/path/to/file


#### completion
Tab Completion.

    $ . $(command -v laws)

OR  

    $ . /path/to/laws


## Note:
This program relies heavily on "AWS Signature Version 4".  

#### References:
  - Signing AWS Requests with Signature Version 4 - Amazon Web Services  
    https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html  
  - Authenticating Requests: Using Query Parameters (AWS Signature Version 4)
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  - Signature Calculations for the Authorization Header:  
    Transferring Payload in a Single Chunk (AWS Signature Version 4) - Amazon Simple Storage Service  
    https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html  
  - GET Bucket (List Objects) Version 2  
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html  
;
README
  return 0
  }

  DateUTC() (
    LANG=C TZ=UTC date +"%Y%m%dT%H%M%SZ"
  )

  Log() (
    level=${1:?"[FATAL] Log(): requires \"level\" as \$1"}
    contents=${2:?"[FATAL] Log(): requires \"contents\" as \$2"}
    case "$level" in
      f|F) contents_leveled="FATAL ${contents}" ;;
      e|E) contents_leveled="ERROR ${contents}" ;;
      w|W) contents_leveled="WARN  ${contents}" ;;
        *) contents_leveled="INFO  ${contents}" ;;
    esac
    printf "%s" "${contents_leveled}" | sed "s/^/$(DateUTC) ${PROGRAM_NAME}[$$]: /" >/dev/stderr
  )

  Contain() (
    contents="$1"
    pattern="${2:?"[FATAL] Contain(): requires \"pattern\" as \$2"}"
    if echo "${contents}" | grep -Eq -- "${pattern}"; then
      return 0
    fi
    return 1
  )

  ContainHelp() (
    Contain "$*" "^[[:space:]]*\-+h(elp)?[[:space:]]*|[[:space:]]+\-+h(elp)?[[:space:]]*$|^[[:space:]]*help[[:space:]]*$"
  )

  CheckDependency() (
    for cmd in "$@"; do
      if ! command -v "${cmd}" >/dev/null; then
        Log E "CheckDependency(): \"${cmd}\" not found in PATH=\"${PATH}\""
        exit 1
      fi
    done
  ); CheckDependency '[' cat curl date grep od openssl printf sed tr

  ParseINIFromStdinToStdout() (
    # For the setting in the ini file, output commands which define them as shell variables prefixed "INI_".
    iniSectionPattern="${1:?"[FATAL] ParseINIFromStdinToStdout(): requires \"iniSectionPattern\" as \$1"}"
    sed "s/[[:blank:]]*\=[[:blank:]]*/=/g; s/[#;].*$//; s/[[:blank:]]*$//; s/^[[:blank:]]*//; s/^\(.*\)=\([^\"\']*\)$/INI_\1=\"\2\"/" /dev/stdin \
      | sed -n "/^\[${iniSectionPattern}\]/,/\[/{/.*\=.*/p;}"
  )

  GetRegion() (
    # 1. already declared
    if [ -z "${region}" ] && [ "${Region}" ]; then
      region="${Region}"
    fi

    # 2. environment variable: AWS_REGION
    if [ -z "${region}" ] && [ "${AWS_REGION}" ]; then
      region="${AWS_REGION}"
    fi

    # 3. config file: ~/.aws/config
    if [ -z "${region}" ] && [ -r ~/.aws/config ]; then
      INI_region=""
      eval "$(ParseINIFromStdinToStdout "\(profile \)*${AWS_PROFILE:-default}" < ~/.aws/config)"
      if [ "${INI_region}" ]; then
        region="${INI_region}"
      else
        Log W "GetRegion(): Failed to parse ~/.aws/config: AWS_PROFILE=${AWS_PROFILE:-default}"
      fi
    fi

    # 4. meta-data
    if [ -z "${region}" ]; then
      region=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.$//' ||:)
    fi

    # check Region
    if [ -z "${region}" ]; then
      ErrorMessage=$(cat <<"ERROR"

GetRegion(): Not specified AWS Region
Follow the steps below to register AWS region:

1. Save config as: ~/.aws/config

    [default]
    region = ap-northeast-1

 ** OR **

1. Set environment variables:

    $ export AWS_REGION=ap-northeast-1
;
ERROR
      )
      Log E "${ErrorMessage}"
      exit 1
    fi

    # return
    echo "${region}"
  )

  APIEndpoint() (
    region="${1:?"[FATAL] APIEndpoint(): requires \"region\" as \$1"}"
    service="${2:?"[FATAL] APIEndpoint(): requires \"service\" as \$2"}"
    case "${service}" in
      s3)
        if [ "${region}" = us-east-1 ]; then
          echo "s3.amazonaws.com"
        else
          echo "s3-${region}.amazonaws.com"
        fi
        ;;
      *)
        Log E "${service} not support"
        return 1
        ;;
    esac
  )

  SetAccessKey() {
    # get credentials from environment variables
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ "${AWS_ACCESS_KEY_ID}" ] && [ "${AWS_SECRET_ACCESS_KEY}" ]; then
        AccessKeyId=${AWS_ACCESS_KEY_ID} SecretAccessKey=${AWS_SECRET_ACCESS_KEY}
      fi
    fi

    # get credentials from `~/.aws/config` and `~/.aws/credentials`
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ -r ~/.aws/credentials ]; then
        INI_aws_access_key_id="" INI_aws_secret_access_key=""
        eval "$(ParseINIFromStdinToStdout "\(profile \)*${AWS_PROFILE:-default}" < ~/.aws/credentials)"
        AccessKeyId="${INI_aws_access_key_id}" SecretAccessKey="${INI_aws_secret_access_key}"
        if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
          Log W "SetAccessKey(): Failed to parse ~/.aws/credentials: AWS_PROFILE=${AWS_PROFILE:-default}"
        fi
      fi
    fi

    # get credentials from Instance Profile
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      InstanceProfile=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || :)
      IAMJSON=$(curl -sS --max-time 1 "http://169.254.169.254/latest/meta-data/iam/security-credentials/${InstanceProfile}" 2>/dev/null ||:)
      AccessKeyId=$(echo "${IAMJSON}" | grep "AccessKeyId" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      SecretAccessKey=$(echo "${IAMJSON}" | grep "SecretAccessKey" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      STSToken=$(echo "${IAMJSON}" | grep "Token" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')

      # if STSToken is null, regarding as not running on EC2.
      if [ -z "${STSToken}" ]; then
      ErrorMessage=$(cat <<"ERROR"

SetAccessKey(): Failed to connect http://169.254.169.254/
Follow the steps below to register your credentials:

1. Save credentials file as: ~/.aws/credentials

    [default]
    aws_access_key_id = AKIA****************
    aws_secret_access_key = ****************************************

 ** OR **

1. Set environment variables:

    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
;
ERROR
      )
      Log E "${ErrorMessage}"
      exit 1
      fi
    fi
  }

  Hex() {
    printf "%s" "$1" | od -v -A n -t x1 | tr -d '[:blank:]|\n'
  }

  HMAC() {
    printf "%s" "$2" | openssl dgst -sha256 -mac HMAC -macopt hexkey:"$1" | sed 's/^.* //'
  }

  SHA256Hash() {
    printf "%s" "$1" | openssl dgst -sha256 | sed 's/^.* //'
  }

  TrimSchemeAndSlashSlash() {
    printf "%s" "$1" | sed 's|^[^:]*://||'
  }

  ExtractPattern() (
    contents=${1:?"[FATAL] ExtractPattern(): requires \"contents\" as \$1"}
    pattern=${2:?"[FATAL] ExtractPattern(): requires \"pattern\" as \$2"}
    echo "${contents}" | grep -Eo "${pattern}"
  )

  ExtractXMLValue() (
    contents=${1:?"[FATAL] ExtractPattern(): requires \"contents\" as \$1"}
    tagName=${2:?"[FATAL] ExtractXMLValue(): requires \"tagName\" as \$2"}
    echo "${contents}" | grep -Eo "<${tagName}>.*</${tagName}>" | sed "s|</*${tagName}>||g"
  )

  ExtractHost() {
    TrimSchemeAndSlashSlash "$1" | sed 's|/.*||'
  }

  ExtractPath() {
    TrimSchemeAndSlashSlash "$1" | grep '/' | sed 's|^[^/]*/||'
  }

  UriEncodeWithoutSlash() {
    printf "%s" "$1" | sed 's|\$|%24|g; s|+|%2B|g; s|:|%3A|g; s|=|%3D|g' # TODO: Perhaps the character `$` may not be handled.
  }

  UriEncode() {
    UriEncodeWithoutSlash "$1" | sed 's|/|%2F|g'
  }

  CanonicalHeader() {
    printf "%s\n" "host:${APIEndpoint}"
    printf "%s\n" "x-amz-content-sha256:${HashedPayload}"
    printf "%s\n" "x-amz-date:${DateISO8601}"
    [ -z "${STSToken}" ] || printf "%s\n" "x-amz-security-token:${STSToken}"
  }

  CanonicalRequest() {
    printf "%s\n" "${HTTPMethod}" # GET
    printf "%s\n" "${RequestPath}" # /your-backet
    printf "%s\n" "${CanonicalQueryString}" # list-type=2&prefix=%2Fpath%2Fto%2Ffile
    printf "%s\n" "$(CanonicalHeader)"
    printf "%s\n" "" # blank lines are required
    printf "%s\n" "$(CanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//')"
    printf "%s\n" "${HashedPayload}"
  }

  SetAWSSignatureV4ForS3Get() {
    # AWS Signature Version 4 for Amazon S3 REST API
    HTTPMethod="GET"
    [ "${APIEndpoint}" ] || APIEndpoint=$([ "${Region}" = us-east-1 ] && echo "s3.amazonaws.com" || echo "s3-${Region}.amazonaws.com")
    DateYMD=$(date +'%Y%m%d')
    DateISO8601=$(TZ=GMT date +'%Y%m%dT%H%M%SZ')
    HashedPayload=$(SHA256Hash "${Payload}")
    CanonicalRequest=$(CanonicalRequest)
    StringtoSign=$(
      printf "%s\n" "AWS4-HMAC-SHA256"
      printf "%s\n" "${DateISO8601}"
      printf "%s\n" "${DateYMD}/${Region}/s3/aws4_request"
      printf "%s\n" "$(SHA256Hash "${CanonicalRequest}")"
    )
    Signature=$(
      HMAC "$(HMAC "$(HMAC "$(HMAC "$(HMAC "$(Hex "AWS4${SecretAccessKey}")" "${DateYMD}")" "${Region}")" "s3")" "aws4_request")" "${StringtoSign}"
    )
    Authorization=$(
      printf "%s" "AWS4-HMAC-SHA256"
      printf "%s" " Credential=${AccessKeyId}/${DateYMD}/${Region}/s3/aws4_request,"
      printf "%s" " SignedHeaders=$(CanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//'),"
      printf "%s" " Signature=${Signature}"
    )
  }

  CallAPIS3Get() {
    {
      printf "%s" "curl -kLsS 'https://${APIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")'"
      printf "%s" " -H 'Host: ${APIEndpoint}'"
      printf "%s" " -H 'x-amz-content-sha256: ${HashedPayload}'"
      printf "%s" " -H 'x-amz-date: ${DateISO8601}'"
      [ -z "${STSToken}" ] || printf "%s" " -H 'x-amz-security-token: ${STSToken}'"
      printf "%s" " -H 'Authorization: ${Authorization}'"
    } | sh
  }

  List() {
    # check sub commands
    case "$1" in
      "") # when $# = 0
        Region=$(GetRegion)
        [ "${APIEndpoint}" ] || APIEndpoint=$(APIEndpoint "${Region}" s3)
        # If there is no argument, list the buckets.
        SetAccessKey
        RequestPath="/" CanonicalQueryString="" Payload=""
        SetAWSSignatureV4ForS3Get
        Response=$(CallAPIS3Get)
        if Contain "${Response}" "</Error>"; then
          echo "${Response}" >/dev/stderr
          exit 1
        fi
        echo "${Response}" | grep -Eo "[^>]*</Name><CreationDate>[^<]*" | sed 's|\([^>]*\)</Name><CreationDate>\([^<]*\)|\2 \1|g;'
        ;;
      *)
        Region=$(GetRegion)
        [ "${APIEndpoint}" ] || APIEndpoint=$(APIEndpoint "${Region}" s3)
        # If there is an argument, list the objects.
        SetAccessKey
        RequestPath="/$(ExtractHost "$1")" Payload=""
        if [ -z "${MaxKeys}" ] || Contain "${MaxKeys}" "[^0-9]"; then MaxKeys=1000; fi
        Prefix=$(UriEncode "$(ExtractPath "$1")")
        CanonicalQueryString="$(
          [ -z "${ContinuationToken}" ] || printf "%s" "continuation-token=${ContinuationToken}&"
        )list-type=2&max-keys=${MaxKeys}$(
          [ -z "${Prefix}" ] || printf "%s" "&prefix=${Prefix}"
        )"
        SetAWSSignatureV4ForS3Get
        Response=$(CallAPIS3Get)
        # check error
        if Contain "${Response}" "</Error>"; then
          if Contain "${Response}" "<Code>PermanentRedirect</Code>"; then
            APIEndpoint=$(ExtractXMLValue "${Response}" "Endpoint")
            List "$@"
          fi
          echo "${Response}" >/dev/stderr
          exit 1
        fi
        # normal
        BucketName=$(ExtractHost "$1")
        ExtractPattern "${Response}" "[^>]*</Key><LastModified>[^<]*" | sed 's|\([^>]*\)</Key><LastModified>\([^<]*\)|\2 '"${BucketName}/"'\1|g'
        if Contain "${Response}" "<NextContinuationToken>[^<]*"; then
          ContinuationToken=$(UriEncode "$(ExtractPattern "${Response}" "<NextContinuationToken>[^<]*" | sed 's|.*>||g')")
          List "$@"
        fi
        ;;
    esac
  }

  Get() {
    Region=$(GetRegion)
    SetAccessKey
    RequestPath="/$(UriEncodeWithoutSlash "$(TrimSchemeAndSlashSlash "$1")")"
    CanonicalQueryString="" Payload=""
    SetAWSSignatureV4ForS3Get
    TmpFile=$(mktemp)
    CallAPIS3Get > "${TmpFile}"
    Response="$(cat "${TmpFile}")"
    if Contain "${Response}" "</Error>"; then
      if Contain "${Response}" "<Code>PermanentRedirect</Code>"; then
        APIEndpoint=$(ExtractXMLValue "${Response}" "Endpoint")
        Get "$@"
      fi
      echo "${Response}" >/dev/stderr
      exit 1
    fi
    # if empty file, remove
    [ -s "${TmpFile}" ] || rm "${TmpFile}"
    cat "${TmpFile}"
  }

  ListArgs() {
    # if args contain "-h" or "--help" or "help" or ..., display README
    if ContainHelp "$*"; then ReadMe; fi
    if [ "$#" = 0 ]; then
      List
    else 
      for arg in "$@"; do
        List "${arg}"
      done
    fi
  }

  Concatenate() {
    # if 0 arg OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" = 0 ] || ContainHelp "$*"; then ReadMe; fi
    for arg in "$@"; do
      Get "${arg}"
    done
  }

  Copy() {
    # if less than 2 args OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" -lt 2 ] || ContainHelp "$*"; then ReadMe; fi
    # copy s3 to local
    if [ -r "$1" ] && [ ! -x "$2" ]; then
      Log E "Copy(): cp ( src=S3 dest=local ) is unimplemented"
      exit 1
    fi
    # copy local to s3
    if [ ! -x "$1" ]; then
      if [ -d "$(dirname "$2")" ]; then
        Get "$1" > "$2"
        exit 0
      fi
    fi
  }

  S3() {
    # check sub commands
    case "$1" in
       ls) shift && ListArgs "$@" ;;
      cat) shift && Concatenate "$@" ;;
       cp) shift && Copy "$@" ;;
        *) ReadMe ;;
    esac
  }

  main() {
    # display version
    if Contain "$*" "-V|\-*version"; then
      echo "${PROGRAM_NAME} ${VERSION}"
      exit 0
    fi

    # check sub commands
    case "$1" in
      s3) shift && S3 "$@" ;;
       *) ReadMe ;;
    esac
  }

  main "$@"

elif [ "$(command -v bash)" ]; then

  # Interactive: laws as completion
  # ref: https://blog.cybozu.io/entry/2016/09/26/080000
  # shellcheck disable=SC2016,SC2034,SC2039
  _laws() {
    local cur prev cword
    _get_comp_words_by_ref -n : cur prev cword
    if [ "${cword}" -eq 1 ]; then
      eval 'COMPREPLY=( $(compgen -W "s3" -- "${cur}") )'
    elif [ "${cword}" -eq 2 ]; then
      if [ "${prev}" = "s3" ]; then
        eval 'COMPREPLY=( $(compgen -W "ls cat cp" -- "${cur}") )'
      fi
    elif [ "${cword}" -eq 3 ]; then
      if [ "${prev}" = "ls" ] || [ "${prev}" = "cat" ]; then
        if [ -z "${__laws_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_completion_previous_execution_time)) -gt 30 ]; then
          __laws_completion_previous_execution_time=$(date +%s)
          __laws_completion_previous_execution="$(bash laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
          eval 'COMPREPLY=( $(compgen -W "${__laws_completion_previous_execution}" -- "${cur}") )'
        else
          eval 'COMPREPLY=( $(compgen -W "${__laws_completion_previous_execution}" -- "${cur}") )'
        fi
      fi
    fi
  }
  # shellcheck disable=SC2039
  [ -z "$(command -v complete)" ] || complete -F _laws laws

fi

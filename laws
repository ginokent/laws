#!/bin/sh
# shellcheck disable=SC1117

if ! echo "$-" | grep -q i; then

  # Non-interactive: execute laws as command

  set -e

  readonly VERSION="0.0.9"
  readonly PROGRAM_NAME="$(basename -- "$0")"

  Laws_Stdout_ReadMe() (
  cat <<"README" >/dev/stderr

laws
====

Lightweight shell script for Amazon Web Service Command Line Interface like AWS CLI.


## TL;DR

    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 ls s3://your-bucket/prefix
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cat s3://your-bucket/path/to/file
    curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws | sh /dev/stdin s3 cp s3://your-bucket/path/to/file /path/to/file


## Install:

    sudo curl -sS https://raw.githubusercontent.com/djeeno/laws/master/laws -o /usr/local/bin/laws && sudo chmod +x $_


## Usage:

When executing this script,
  - Please use it on EC2 which has IAM Role allowed access to Amazon S3,
  - or save `~/.aws/config` and `~/.aws/credentials`,
  - or set the following environment variables:

    ```
    $ export AWS_REGION=ap-northeast-1
    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
    ```


#### `help`
Display help.  

    $ laws help


#### `s3 ls`
List the contents on Amazon S3.  

    $ laws s3 ls [<your-bucket>[<prefix>]]


#### `s3 cat`
Get the contents of the file on Amazon S3.  

    $ laws s3 cat s3://your-bucket/path/to/file ...


#### `s3 cp`
Copy a file.  

    $ laws s3 cp s3://your-bucket/path/to/file /path/to/file
    $ (unimplemented) laws s3 cp /path/to/file s3://your-bucket/path/to/file
    $ (unimplemented) laws s3 cp s3://your-bucket-b/path/to/file s3://your-bucket-a/path/to/file


#### completion
Tab Completion.

    $ . $(command -v laws)

OR  

    $ . /path/to/laws


## Note:
This program relies heavily on "AWS Signature Version 4".  

#### References:
  - Signing AWS Requests with Signature Version 4 - Amazon Web Services  
    https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html  
  - Authenticating Requests: Using Query Parameters (AWS Signature Version 4)
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/sigv4-query-string-auth.html
  - Signature Calculations for the Authorization Header:  
    Transferring Payload in a Single Chunk (AWS Signature Version 4) - Amazon Simple Storage Service  
    https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-header-based-auth.html  
  - GET Bucket (List Objects) Version 2  
    https://docs.aws.amazon.com/ja_jp/AmazonS3/latest/API/v2-RESTBucketGET.html  
;
README
  return 0
  )

  Common_Stdout_DateUTC() (
    LANG=C TZ=UTC date +"%Y%m%dT%H%M%SZ"
  )

  Common_Stdout_Log() (
    level=${1:?"[FATAL] Common_Stdout_Log(): requires \"level\" as \$1"}
    logMessages=${2:?"[FATAL] Common_Stdout_Log(): requires \"logMessages\" as \$2"}
    case "$level" in
      f|F) logMessagesLeveled="FATAL ${logMessages}" ;;
      e|E) logMessagesLeveled="ERROR ${logMessages}" ;;
      w|W) logMessagesLeveled="WARN  ${logMessages}" ;;
        *) logMessagesLeveled="INFO  ${logMessages}" ;;
    esac
    printf "%s\n" "${logMessagesLeveled}" | sed "s/^/$(Common_Stdout_DateUTC) ${PROGRAM_NAME}[$$]: /" >/dev/stderr
  )

  Common_Containing_MultiBytesChar() (
    contents="$1"
    echo "${contents}" | LANG=C grep -Evq '^[[:cntrl:][:print:]]*$'
  )

  Common_Containing_Regex() (
    pattern="${1:?"[FATAL] Common_Containing_Regex(): requires \"pattern\" as \$1"}"
    contents="$2"
    if echo "${contents}" | grep -Eq -- "${pattern}"; then
      return 0
    fi
    return 1
  )

  Common_Containing_HelpOption() (
    Common_Containing_Regex "^[[:space:]]*\-+h(elp)?[[:space:]]*|[[:space:]]+\-+h(elp)?[[:space:]]*$|^[[:space:]]*help[[:space:]]*$" "$*"
  )

  Common_Check_Dependency() (
    for cmd in "$@"; do
      if ! command -v "${cmd}" >/dev/null; then
        Common_Stdout_Log E "Common_Check_Dependency(): \"${cmd}\" not found in PATH=\"${PATH}\""
        exit 1
      fi
    done
  ); Common_Check_Dependency '[' cat curl date grep od openssl printf sed tr

  Common_Stdout_ParsedINI() (
    # For the setting in the ini file, output commands which define them as shell variables prefixed "INI_".
    iniSectionPattern="${1:?"[FATAL] Common_Stdout_ParsedINI(): requires \"iniSectionPattern\" as \$1"}"
    file=${2:?"[FATAL] Common_Stdout_ParsedINI(): requires \"file\" as \$2"}
    sed "s/[[:blank:]]*\=[[:blank:]]*/=/g; s/[#;].*$//; s/[[:blank:]]*$//; s/^[[:blank:]]*//; s/^\(.*\)=\([^\"\']*\)$/INI_\1=\"\2\"/" "${file}" \
      | sed -n "/^\[${iniSectionPattern}\]/,/\[/{/.*\=.*/p;}"
  )

  Common_Stdout_Hex() (
    printf "%s" "$1" | od -v -A n -t x1 | tr -d '[:blank:]|\n'
  )

  Common_Stdout_HMAC() (
    printf "%s" "$2" | openssl dgst -sha256 -mac HMAC -macopt hexkey:"$1" | sed 's/^.* //'
  )

  Common_Stdout_SHA256Hash() (
    printf "%s" "$1" | openssl dgst -sha256 | sed 's/^.* //'
  )

  Common_Stdout_SchemeAndSlashSlashRemoved() (
    printf "%s" "$1" | sed 's|^[^:]*://||'
  )

  Common_Stdout_ExtractedByPattern() (
    pattern="${1:?"[FATAL] Common_Stdout_ExtractedByPattern(): requires \"pattern\" as \$1"}"
    contents="${2:?"[FATAL] Common_Stdout_ExtractedByPattern(): requires \"contents\" as \$2"}"
    echo "${contents}" | grep -Eo "${pattern}"
  )

  Common_Stdout_ExtractedXMLValue() (
    tagName="${1:?"[FATAL] Common_Stdout_ExtractedXMLValue(): requires \"tagName\" as \$1"}"
    contents="${2:?"[FATAL] Common_Stdout_ExtractedXMLValue(): requires \"contents\" as \$2"}"
    echo "${contents}" | grep -Eo "<${tagName}>.*</${tagName}>" | sed "s|</*${tagName}>||g"
  )

  Common_Stdout_ExtractedHTTPHost() {
    Common_Stdout_SchemeAndSlashSlashRemoved "$1" | sed 's|/.*||'
  }

  Common_Stdout_ExtractedHTTPPath() {
    Common_Stdout_SchemeAndSlashSlashRemoved "$1" | grep '/' | sed 's|^[^/]*/||'
  }

  Common_Stdout_UriEncoded() {
    contents="$1"
    if Common_Containing_MultiBytesChar "${contents}"; then
      Common_Stdout_Log E "containing multi bytes char"
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        [[:alnum:].~_-])
          printf "%s" "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  }

  Common_Stdout_UriEncodedWithoutSlash() {
    contents="$1"
    if Common_Containing_MultiBytesChar "${contents}"; then
      Common_Stdout_Log E "containing multi bytes char"
      exit 1
    fi
    LC_COLLATE=C
    # shellcheck disable=SC2059
    printf "$(echo "$1" | sed 's/\(.\)/\1\\n/g')" | while read -r LINE; do
      case "$LINE" in
        [[:alnum:].~_-]|/)
          printf "%s" "$LINE"
          ;;
        *)
          printf '%%%02X' "'$LINE"
          ;;
      esac
    done
  }

  Laws_Stdout_Region() (
    # 1. already declared
    if [ -z "${region}" ] && [ "${Region}" ]; then
      region="${Region}"
    fi

    # 2. environment variable: AWS_REGION
    if [ -z "${region}" ] && [ "${AWS_REGION}" ]; then
      region="${AWS_REGION}"
    fi

    # 3. config file: ~/.aws/config
    if [ -z "${region}" ] && [ -r ~/.aws/config ]; then
      INI_region=""
      eval "$(Common_Stdout_ParsedINI "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/config)"
      if [ "${INI_region}" ]; then
        region="${INI_region}"
      else
        Common_Stdout_Log W "Laws_Stdout_Region(): Failed to parse ~/.aws/config: AWS_PROFILE=${AWS_PROFILE:-default}"
      fi
    fi

    # 4. meta-data
    if [ -z "${region}" ]; then
      region=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/placement/availability-zone 2>/dev/null | sed 's/.$//' ||:)
    fi

    # check Region
    if [ -z "${region}" ]; then
      ErrorMessage=$(cat <<"ERROR"

Laws_Stdout_Region(): Not specified AWS Region
Follow the steps below to register AWS region:

1. Save config as: ~/.aws/config

    [default]
    region = ap-northeast-1

 ** OR **

1. Set environment variables:

    $ export AWS_REGION=ap-northeast-1
;
ERROR
      )
      Common_Stdout_Log E "${ErrorMessage}"
      exit 1
    fi

    # return
    echo "${region}"
  )

  Laws_Stdout_APIEndpoint() (
    service="${1:?"[FATAL] Laws_Stdout_APIEndpoint(): requires \"service\" as \$1"}"
    region="${2:?"[FATAL] Laws_Stdout_APIEndpoint(): requires \"region\" as \$2"}"
    case "${service}" in
      s3)
        if [ "${region}" = us-east-1 ]; then
          echo "s3.amazonaws.com"
        else
          echo "s3-${region}.amazonaws.com"
        fi
        ;;
      *)
        Common_Stdout_Log E "${service} not support"
        return 1
        ;;
    esac
  )

  Laws_Set_AccessKey() {
    # get credentials from environment variables
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ "${AWS_ACCESS_KEY_ID}" ] && [ "${AWS_SECRET_ACCESS_KEY}" ]; then
        AccessKeyId=${AWS_ACCESS_KEY_ID} SecretAccessKey=${AWS_SECRET_ACCESS_KEY}
      fi
    fi

    # get credentials from `~/.aws/config` and `~/.aws/credentials`
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      if [ -r ~/.aws/credentials ]; then
        INI_aws_access_key_id="" INI_aws_secret_access_key=""
        eval "$(Common_Stdout_ParsedINI "\(profile \)*${AWS_PROFILE:-default}" ~/.aws/credentials)"
        AccessKeyId="${INI_aws_access_key_id}" SecretAccessKey="${INI_aws_secret_access_key}"
        if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
          Common_Stdout_Log W "Laws_Set_AccessKey(): Failed to parse ~/.aws/credentials: AWS_PROFILE=${AWS_PROFILE:-default}"
        fi
      fi
    fi

    # get credentials from Instance Profile
    if [ -z "${AccessKeyId}" ] || [ -z "${SecretAccessKey}" ]; then
      InstanceProfile=$(curl -sS --max-time 1 http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || :)
      IAMJSON=$(curl -sS --max-time 1 "http://169.254.169.254/latest/meta-data/iam/security-credentials/${InstanceProfile}" 2>/dev/null ||:)
      AccessKeyId=$(echo "${IAMJSON}" | grep "AccessKeyId" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      SecretAccessKey=$(echo "${IAMJSON}" | grep "SecretAccessKey" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')
      STSToken=$(echo "${IAMJSON}" | grep "Token" | sed 's/.*"[^"]*" : "\([^"]*\)".*/\1/g')

      # if STSToken is null, regarding as not running on EC2.
      if [ -z "${STSToken}" ]; then
      ErrorMessage=$(cat <<"ERROR"

Laws_Set_AccessKey(): Failed to connect http://169.254.169.254/
Follow the steps below to register your credentials:

1. Save credentials file as: ~/.aws/credentials

    [default]
    aws_access_key_id = AKIA****************
    aws_secret_access_key = ****************************************

 ** OR **

1. Set environment variables:

    $ export AWS_ACCESS_KEY_ID=AKIA****************
    $ export AWS_SECRET_ACCESS_KEY=****************************************
;
ERROR
      )
      Common_Stdout_Log E "${ErrorMessage}"
      exit 1
      fi
    fi
  }

  Laws_Stdout_CanonicalHeader() {
    printf "%s\n" "host:${APIEndpoint}"
    printf "%s\n" "x-amz-content-sha256:${HashedPayload}"
    printf "%s\n" "x-amz-date:${DateISO8601}"
    [ -z "${STSToken}" ] || printf "%s\n" "x-amz-security-token:${STSToken}"
  }

  Laws_Stdout_CanonicalRequest() {
    printf "%s\n" "${HTTPMethod}" # GET
    printf "%s\n" "${RequestPath}" # /your-backet
    printf "%s\n" "${CanonicalQueryString}" # list-type=2&prefix=%2Fpath%2Fto%2Ffile
    printf "%s\n" "$(Laws_Stdout_CanonicalHeader)"
    printf "%s\n" "" # blank lines are required
    printf "%s\n" "$(Laws_Stdout_CanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//')"
    printf "%s\n" "${HashedPayload}"
  }

  Laws_Set_AWSSignatureV4ForS3Get() {
    # AWS Signature Version 4 for Amazon S3 REST API
    HTTPMethod="GET"
    [ "${APIEndpoint}" ] || APIEndpoint=$(Laws_Stdout_APIEndpoint s3 "${Region}")
    DateYMD=$(date +'%Y%m%d')
    DateISO8601=$(TZ=GMT date +'%Y%m%dT%H%M%SZ')
    HashedPayload=$(Common_Stdout_SHA256Hash "${Payload}")
    CanonicalRequest=$(Laws_Stdout_CanonicalRequest)
    StringtoSign=$(
      printf "%s\n" "AWS4-HMAC-SHA256"
      printf "%s\n" "${DateISO8601}"
      printf "%s\n" "${DateYMD}/${Region}/s3/aws4_request"
      printf "%s\n" "$(Common_Stdout_SHA256Hash "${CanonicalRequest}")"
    )
    Signature=$(
      Common_Stdout_HMAC "$(
        Common_Stdout_HMAC "$(
          Common_Stdout_HMAC "$(
            Common_Stdout_HMAC "$(
              Common_Stdout_HMAC "$(
                Common_Stdout_Hex "AWS4${SecretAccessKey}"
              )" "${DateYMD}"
            )" "${Region}"
          )" "s3"
        )" "aws4_request"
      )" "${StringtoSign}"
    )
    Authorization=$(
      printf "%s" "AWS4-HMAC-SHA256"
      printf "%s" " Credential=${AccessKeyId}/${DateYMD}/${Region}/s3/aws4_request,"
      printf "%s" " SignedHeaders=$(Laws_Stdout_CanonicalHeader | sed 's/:.*/;/g' | tr -d '\n' | sed 's/;$//'),"
      printf "%s" " Signature=${Signature}"
    )
  }

  CallAPIS3Get() {
    {
      printf "%s" "curl -kLsS 'https://${APIEndpoint}${RequestPath}$([ -z "${CanonicalQueryString}" ] || echo "?${CanonicalQueryString}")'"
      printf "%s" " -H 'Host: ${APIEndpoint}'"
      printf "%s" " -H 'x-amz-content-sha256: ${HashedPayload}'"
      printf "%s" " -H 'x-amz-date: ${DateISO8601}'"
      [ -z "${STSToken}" ] || printf "%s" " -H 'x-amz-security-token: ${STSToken}'"
      printf "%s" " -H 'Authorization: ${Authorization}'"
    } | sh
  }

  List() {
    # check sub commands
    case "$1" in
      "") # when $# = 0
        Region=$(Laws_Stdout_Region)
        [ "${APIEndpoint}" ] || APIEndpoint=$(Laws_Stdout_APIEndpoint s3 "${Region}")
        # If there is no argument, list the buckets.
        Laws_Set_AccessKey
        RequestPath="/" CanonicalQueryString="" Payload=""
        Laws_Set_AWSSignatureV4ForS3Get
        Response=$(CallAPIS3Get)
        if Common_Containing_Regex "</Error>" "${Response}"; then
          echo "${Response}" >/dev/stderr
          exit 1
        fi
        echo "${Response}" | grep -Eo "[^>]*</Name><CreationDate>[^<]*" | sed 's|\([^>]*\)</Name><CreationDate>\([^<]*\)|\2 \1|g;'
        ;;
      *)
        Region=$(Laws_Stdout_Region)
        [ "${APIEndpoint}" ] || APIEndpoint=$(Laws_Stdout_APIEndpoint s3 "${Region}")
        # If there is an argument, list the objects.
        Laws_Set_AccessKey
        RequestPath="/$(Common_Stdout_ExtractedHTTPHost "$1")" Payload=""
        if [ -z "${MaxKeys}" ] || Common_Containing_Regex "[^0-9]" "${MaxKeys}"; then MaxKeys=1000; fi
        Prefix=$(Common_Stdout_UriEncoded "$(Common_Stdout_ExtractedHTTPPath "$1")")
        CanonicalQueryString="$(
          [ -z "${ContinuationToken}" ] || printf "%s" "continuation-token=${ContinuationToken}&"
        )list-type=2&max-keys=${MaxKeys}$(
          [ -z "${Prefix}" ] || printf "%s" "&prefix=${Prefix}"
        )"
        Laws_Set_AWSSignatureV4ForS3Get
        Response=$(CallAPIS3Get)
        # check error
        if Common_Containing_Regex "</Error>" "${Response}"; then
          if Common_Containing_Regex "<Code>PermanentRedirect</Code>" "${Response}"; then
            APIEndpoint=$(Common_Stdout_ExtractedXMLValue "Endpoint" "${Response}")
            List "$@"
          fi
          echo "${Response}" >/dev/stderr
          exit 1
        fi
        # normal
        BucketName=$(Common_Stdout_ExtractedHTTPHost "$1")
        Common_Stdout_ExtractedByPattern "[^>]*</Key><LastModified>[^<]*" "${Response}" | sed 's|\([^>]*\)</Key><LastModified>\([^<]*\)|\2 '"${BucketName}/"'\1|g'
        if Common_Containing_Regex "<NextContinuationToken>[^<]*" "${Response}"; then
          ContinuationToken=$(Common_Stdout_UriEncoded "$(Common_Stdout_ExtractedByPattern "<NextContinuationToken>[^<]*" "${Response}" | sed 's|.*>||g')")
          List "$@"
        fi
        ;;
    esac
  }

  Get() {
    Region=$(Laws_Stdout_Region)
    Laws_Set_AccessKey
    RequestPath="/$(Common_Stdout_UriEncodedWithoutSlash "$(Common_Stdout_SchemeAndSlashSlashRemoved "$1")")"
    CanonicalQueryString="" Payload=""
    Laws_Set_AWSSignatureV4ForS3Get
    TmpFile=$(mktemp)
    CallAPIS3Get > "${TmpFile}"
    Response="$(cat "${TmpFile}")"
    if Common_Containing_Regex "</Error>" "${Response}"; then
      if Common_Containing_Regex "<Code>PermanentRedirect</Code>" "${Response}"; then
        APIEndpoint=$(Common_Stdout_ExtractedXMLValue "Endpoint" "${Response}")
        Get "$@"
      fi
      echo "${Response}" >/dev/stderr
      exit 1
    fi
    # if empty file, remove
    [ -s "${TmpFile}" ] || rm "${TmpFile}"
    cat "${TmpFile}"
  }

  ListArgs() {
    # if args contain "-h" or "--help" or "help" or ..., display README
    if Common_Containing_HelpOption "$*"; then Laws_Stdout_ReadMe; fi
    if [ "$#" = 0 ]; then
      List
    else 
      for arg in "$@"; do
        List "${arg}"
      done
    fi
  }

  Concatenate() {
    # if 0 arg OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" = 0 ] || Common_Containing_HelpOption "$*"; then Laws_Stdout_ReadMe; fi
    for arg in "$@"; do
      Get "${arg}"
    done
  }

  Copy() {
    # if less than 2 args OR args contain "-h" or "--help" or "help" or ..., display README
    if [ "$#" -lt 2 ] || Common_Containing_HelpOption "$*"; then Laws_Stdout_ReadMe; fi
    # copy s3 to local
    if [ -r "$1" ] && [ ! -x "$2" ]; then
      Common_Stdout_Log E "Copy(): cp ( src=S3 dest=local ) is unimplemented"
      exit 1
    fi
    # copy local to s3
    if [ ! -x "$1" ]; then
      if [ -d "$(dirname "$2")" ]; then
        Get "$1" > "$2"
        exit 0
      fi
    fi
  }

  S3() {
    # check sub commands
    case "$1" in
       ls) shift && ListArgs "$@" ;;
      cat) shift && Concatenate "$@" ;;
       cp) shift && Copy "$@" ;;
        *) Laws_Stdout_ReadMe ;;
    esac
  }

  main() {
    # display version
    if Common_Containing_Regex "-V|\-*version" "$*"; then
      echo "${PROGRAM_NAME} ${VERSION}"
      exit 0
    fi

    # check sub commands
    case "$1" in
      s3) shift && S3 "$@" ;;
       *) Laws_Stdout_ReadMe ;;
    esac
  }

  main "$@"

elif [ "$(command -v bash)" ]; then

  # Interactive: laws as completion
  # ref: https://blog.cybozu.io/entry/2016/09/26/080000
  # shellcheck disable=SC2016,SC2034,SC2039
  _laws() {
    local cur prev cword
    _get_comp_words_by_ref -n : cur prev cword
    if [ "${cword}" -eq 1 ]; then
      eval 'COMPREPLY=( $(compgen -W "s3" -- "${cur}") )'
    elif [ "${cword}" -eq 2 ]; then
      if [ "${prev}" = "s3" ]; then
        eval 'COMPREPLY=( $(compgen -W "ls cat cp" -- "${cur}") )'
      fi
    elif [ "${cword}" -eq 3 ]; then
      if [ "${prev}" = "ls" ] || [ "${prev}" = "cat" ]; then
        if [ -z "${__laws_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_completion_previous_execution_time)) -gt 30 ]; then
          __laws_completion_previous_execution_time=$(date +%s)
          __laws_completion_previous_execution="$(bash laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
        fi
        eval 'COMPREPLY=( $(compgen -W "${__laws_completion_previous_execution}" -- "${cur}") )'
      elif [ "${prev}" = "cp" ]; then
        if [ -z "${__laws_completion_previous_execution_time}" ] || [ $(($(date +%s)-__laws_completion_previous_execution_time)) -gt 30 ]; then
          __laws_completion_previous_execution_time=$(date +%s)
          __laws_completion_previous_execution="$(bash laws s3 ls | sed 's/^[^[:blank:]]*[[:blank:]]//' | tr '\n' ' ')"
        fi
        eval 'COMPREPLY=( $(compgen -W "${__laws_completion_previous_execution} $(ls -d ./* ./.*)" -- "${cur}") )'
      fi
    fi
  }
  # shellcheck disable=SC2039
  [ -z "$(command -v complete)" ] || complete -F _laws laws

fi
